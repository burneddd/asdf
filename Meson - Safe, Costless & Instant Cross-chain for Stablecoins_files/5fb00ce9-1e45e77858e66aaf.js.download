"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[412],{2882:function(e,t,n){var r,a=Object.create,s=Object.defineProperty,i=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,c=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty,d=(e,t)=>{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},u=(e,t,n,r)=>{if(t&&"object"===typeof t||"function"===typeof t)for(let a of o(t))l.call(e,a)||a===n||s(e,a,{get:()=>t[a],enumerable:!(r=i(t,a))||r.enumerable});return e},h=(e,t,n)=>(n=null!=e?a(c(e)):{},u(!t&&e&&e.__esModule?n:s(n,"default",{value:e,enumerable:!0}),e)),p={};d(p,{Account:()=>ha,AccountInterface:()=>ga,BlockStatus:()=>se,BlockTag:()=>ie,CairoCustomEnum:()=>Nt,CairoOption:()=>Dt,CairoOptionVariant:()=>xt,CairoResult:()=>Ft,CairoResultVariant:()=>Rt,CallData:()=>rn,Contract:()=>va,ContractFactory:()=>Ta,ContractInterface:()=>Aa,CustomError:()=>or,EntryPointType:()=>ee,GatewayError:()=>lr,HttpError:()=>dr,LibraryError:()=>cr,Litteral:()=>Z,Provider:()=>Ur,ProviderInterface:()=>pa,RPC:()=>oe,RpcProvider:()=>xr,SIMULATION_FLAG:()=>J,Sequencer:()=>_e,SequencerProvider:()=>Br,Signer:()=>da,SignerInterface:()=>jr,TransactionExecutionStatus:()=>ae,TransactionFinalityStatus:()=>re,TransactionStatus:()=>ne,TransactionType:()=>te,Uint:()=>Q,ValidateType:()=>z,addAddressPadding:()=>Sa,buildUrl:()=>Lr,cairo:()=>tt,constants:()=>f,contractClassResponseToLegacyCompiledContract:()=>Qn,defaultProvider:()=>fa,ec:()=>on,encode:()=>g,events:()=>ya,extractContractHashes:()=>zn,fixProto:()=>ir,fixStack:()=>sr,getCalldata:()=>wa,getChecksumAddress:()=>Na,getDefaultNodeUrl:()=>Ir,hash:()=>an,isSierra:()=>Jn,isUrl:()=>$r,json:()=>dn,merkle:()=>zr,num:()=>be,number:()=>Da,parseUDCEvent:()=>ua,provider:()=>tr,selector:()=>Ve,shortString:()=>qe,splitArgsAndOptions:()=>Ea,stark:()=>Vn,starknetId:()=>ur,transaction:()=>Mr,typedData:()=>Jr,types:()=>X,uint256:()=>nt,validateAndParseAddress:()=>Oa,validateChecksumAddress:()=>xa}),e.exports=(r=p,u(s({},"__esModule",{value:!0}),r));var f={};d(f,{API_VERSION:()=>U,BN_FEE_TRANSACTION_VERSION_1:()=>H,BN_FEE_TRANSACTION_VERSION_2:()=>$,BN_TRANSACTION_VERSION_1:()=>F,BN_TRANSACTION_VERSION_2:()=>P,BaseUrl:()=>j,HEX_STR_TRANSACTION_VERSION_1:()=>D,HEX_STR_TRANSACTION_VERSION_2:()=>R,IS_BROWSER:()=>m,MASK_250:()=>V,MASK_251:()=>B,NetworkName:()=>M,RPC_GOERLI_NODES:()=>Y,RPC_MAINNET_NODES:()=>W,StarknetChainId:()=>K,TEXT_TO_FELT_MAX_LEN:()=>x,TransactionHashPrefix:()=>q,UDC:()=>G,ZERO:()=>L});var g={};d(g,{IS_BROWSER:()=>m,addHexPrefix:()=>A,arrayBufferToString:()=>_,atobUniversal:()=>C,btoaUniversal:()=>k,buf2hex:()=>w,calcByteLength:()=>I,padLeft:()=>T,pascalToSnake:()=>N,removeHexPrefix:()=>v,sanitizeBytes:()=>S,sanitizeHex:()=>O,stringToArrayBuffer:()=>b,utf8ToArray:()=>E});var y=n(89862),m="undefined"!==typeof window;function _(e){return new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"")}function E(e){return(new TextEncoder).encode(e)}function b(e){return E(e)}function C(e){return y.base64.decode(e)}function k(e){return y.base64.encode(new Uint8Array(e))}function w(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}function v(e){return e.replace(/^0x/i,"")}function A(e){return`0x${v(e)}`}function T(e,t,n="0"){return function(e,t,n,r="0"){const a=t-e.length;let s=e;if(a>0){const t=r.repeat(a);s=n?t+e:e+t}return s}(e,t,!0,n)}function I(e,t=8){const{length:n}=e,r=n%t;return r?(n-r)/t*t+t:n}function S(e,t=8,n="0"){return T(e,I(e,t),n)}function O(e){return(e=S(e=v(e),2))&&(e=A(e)),e}var N=e=>/[a-z]/.test(e)?e.split(/(?=[A-Z])/).join("_").toUpperCase():e,x=31,D="0x1",R="0x2",F=1n,P=2n,H=2n**128n+F,$=2n**128n+P,L=0n,V=2n**250n-1n,B=2n**251n,U=L,j=(e=>(e.SN_MAIN="https://alpha-mainnet.starknet.io",e.SN_GOERLI="https://alpha4.starknet.io",e))(j||{}),M=(e=>(e.SN_MAIN="SN_MAIN",e.SN_GOERLI="SN_GOERLI",e))(M||{}),K=(e=>(e.SN_MAIN="0x534e5f4d41494e",e.SN_GOERLI="0x534e5f474f45524c49",e))(K||{}),q=(e=>(e.DECLARE="0x6465636c617265",e.DEPLOY="0x6465706c6f79",e.DEPLOY_ACCOUNT="0x6465706c6f795f6163636f756e74",e.INVOKE="0x696e766f6b65",e.L1_HANDLER="0x6c315f68616e646c6572",e))(q||{}),G={ADDRESS:"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf",ENTRYPOINT:"deployContract"},Y=["https://starknet-testnet.public.blastapi.io/rpc/v0.5","https://limited-rpc.nethermind.io/goerli-juno/v0_5"],W=["https://starknet-mainnet.public.blastapi.io/rpc/v0.5","https://limited-rpc.nethermind.io/mainnet-juno/v0_5"],X={};d(X,{BlockStatus:()=>se,BlockTag:()=>ie,EntryPointType:()=>ee,Litteral:()=>Z,RPC:()=>oe,SIMULATION_FLAG:()=>J,Sequencer:()=>_e,TransactionExecutionStatus:()=>ae,TransactionFinalityStatus:()=>re,TransactionStatus:()=>ne,TransactionType:()=>te,Uint:()=>Q,ValidateType:()=>z});var J=(e=>(e.SKIP_VALIDATE="SKIP_VALIDATE",e.SKIP_EXECUTE="SKIP_EXECUTE",e))(J||{}),z=(e=>(e.DEPLOY="DEPLOY",e.CALL="CALL",e.INVOKE="INVOKE",e))(z||{}),Q=(e=>(e.u8="core::integer::u8",e.u16="core::integer::u16",e.u32="core::integer::u32",e.u64="core::integer::u64",e.u128="core::integer::u128",e.u256="core::integer::u256",e))(Q||{}),Z=(e=>(e.ClassHash="core::starknet::class_hash::ClassHash",e.ContractAddress="core::starknet::contract_address::ContractAddress",e))(Z||{}),ee=(e=>(e.EXTERNAL="EXTERNAL",e.L1_HANDLER="L1_HANDLER",e.CONSTRUCTOR="CONSTRUCTOR",e))(ee||{}),te=(e=>(e.DECLARE="DECLARE",e.DEPLOY="DEPLOY",e.DEPLOY_ACCOUNT="DEPLOY_ACCOUNT",e.INVOKE="INVOKE_FUNCTION",e))(te||{}),ne=(e=>(e.NOT_RECEIVED="NOT_RECEIVED",e.RECEIVED="RECEIVED",e.ACCEPTED_ON_L2="ACCEPTED_ON_L2",e.ACCEPTED_ON_L1="ACCEPTED_ON_L1",e.REJECTED="REJECTED",e.REVERTED="REVERTED",e))(ne||{}),re=(e=>(e.NOT_RECEIVED="NOT_RECEIVED",e.RECEIVED="RECEIVED",e.ACCEPTED_ON_L2="ACCEPTED_ON_L2",e.ACCEPTED_ON_L1="ACCEPTED_ON_L1",e))(re||{}),ae=(e=>(e.REJECTED="REJECTED",e.REVERTED="REVERTED",e.SUCCEEDED="SUCCEEDED",e))(ae||{}),se=(e=>(e.PENDING="PENDING",e.ACCEPTED_ON_L1="ACCEPTED_ON_L1",e.ACCEPTED_ON_L2="ACCEPTED_ON_L2",e.REJECTED="REJECTED",e))(se||{}),ie=(e=>(e.pending="pending",e.latest="latest",e))(ie||{}),oe={};d(oe,{EBlockTag:()=>ye,EDataAvailabilityMode:()=>me,ESimulationFlag:()=>he,ETransactionExecutionStatus:()=>ge,ETransactionFinalityStatus:()=>fe,ETransactionStatus:()=>pe,ETransactionType:()=>ue,Errors:()=>le,JRPC:()=>ce,SPEC:()=>de});var ce={},le={},de={},ue=(e=>(e.DECLARE="DECLARE",e.DEPLOY="DEPLOY",e.DEPLOY_ACCOUNT="DEPLOY_ACCOUNT",e.INVOKE="INVOKE",e.L1_HANDLER="L1_HANDLER",e))(ue||{}),he=(e=>(e.SKIP_VALIDATE="SKIP_VALIDATE",e.SKIP_FEE_CHARGE="SKIP_FEE_CHARGE",e))(he||{}),pe=(e=>(e.RECEIVED="RECEIVED",e.REJECTED="REJECTED",e.ACCEPTED_ON_L2="ACCEPTED_ON_L2",e.ACCEPTED_ON_L1="ACCEPTED_ON_L1",e))(pe||{}),fe=(e=>(e.ACCEPTED_ON_L2="ACCEPTED_ON_L2",e.ACCEPTED_ON_L1="ACCEPTED_ON_L1",e))(fe||{}),ge=(e=>(e.SUCCEEDED="SUCCEEDED",e.REVERTED="REVERTED",e))(ge||{}),ye=(e=>(e.LATEST="latest",e.PENDING="pending",e))(ye||{}),me=(e=>(e.L1="L1",e.L2="L2",e))(me||{}),_e={};function Ee(e,t){if(!e)throw new Error(t||"Assertion failure")}var be={};d(be,{assertInRange:()=>Ne,bigNumberishArrayToDecimalStringArray:()=>xe,bigNumberishArrayToHexadecimalStringArray:()=>De,cleanHex:()=>Oe,getDecimalString:()=>Fe,getHexString:()=>Pe,getHexStringArray:()=>He,hexToBytes:()=>Le,hexToDecimalString:()=>Se,isBigInt:()=>ve,isHex:()=>ke,isStringWholeNumber:()=>Re,toBigInt:()=>we,toCairoBool:()=>$e,toHex:()=>Ae,toHexString:()=>Te,toStorageKey:()=>Ie});var Ce=n(40219);function ke(e){return/^0x[0-9a-f]*$/i.test(e)}function we(e){return BigInt(e)}function ve(e){return"bigint"===typeof e}function Ae(e){return A(we(e).toString(16))}var Te=Ae;function Ie(e){return A(we(e).toString(16).padStart(64,"0"))}function Se(e){return BigInt(A(e)).toString(10)}var Oe=e=>e.toLowerCase().replace(/^(0x)0+/,"$1");function Ne(e,t,n,r=""){const a=""===r?"invalid length":`invalid ${r} length`,s=BigInt(e),i=BigInt(t),o=BigInt(n);Ee(s>=i&&s<=o,`Message not signable, ${a}.`)}function xe(e){return e.map((e=>we(e).toString(10)))}function De(e){return e.map((e=>Ae(e)))}var Re=e=>/^\d+$/.test(e);function Fe(e){if(ke(e))return Se(e);if(Re(e))return e;throw new Error(`${e} need to be hex-string or whole-number-string`)}function Pe(e){if(ke(e))return e;if(Re(e))return Te(e);throw new Error(`${e} need to be hex-string or whole-number-string`)}function He(e){return e.map((e=>Pe(e)))}var $e=e=>(+e).toString();function Le(e){if(!ke(e))throw new Error(`${e} need to be a hex-string`);let t=v(e);return t.length%2!==0&&(t=`0${t}`),(0,Ce.hexToBytes)(t)}var Ve={};d(Ve,{getSelector:()=>Ke,getSelectorFromName:()=>Me,keccakBn:()=>Ue,starknetKeccak:()=>je});var Be=n(37962);function Ue(e){const t=v(Ae(BigInt(e))),n=t.length%2===0?t:`0${t}`;return A((0,Be.keccak)(Le(A(n))).toString(16))}function je(e){const t=BigInt(function(e){return A((0,Be.keccak)(E(e)).toString(16))}(e));return t&V}function Me(e){return Ae(je(e))}function Ke(e){return ke(e)?e:Re(e)?Te(e):Me(e)}var qe={};function Ge(e){return/^[\x00-\x7F]*$/.test(e)}function Ye(e){return e.length<=x}function We(e){return/^[0-9]*$/i.test(e)}function Xe(e){return"string"===typeof e&&!ke(e)&&!Re(e)}d(qe,{decodeShortString:()=>et,encodeShortString:()=>Ze,isASCII:()=>Ge,isDecimalString:()=>We,isLongText:()=>ze,isShortString:()=>Ye,isShortText:()=>Je,isText:()=>Xe,splitLongString:()=>Qe});var Je=e=>Xe(e)&&Ye(e),ze=e=>Xe(e)&&!Ye(e);function Qe(e){const t=RegExp(`[^]{1,${x}}`,"g");return e.match(t)||[]}function Ze(e){if(!Ge(e))throw new Error(`${e} is not an ASCII string`);if(!Ye(e))throw new Error(`${e} is too long`);return A(e.replace(/./g,(e=>e.charCodeAt(0).toString(16))))}function et(e){if(!Ge(e))throw new Error(`${e} is not an ASCII string`);if(ke(e))return v(e).replace(/.{2}/g,(e=>String.fromCharCode(parseInt(e,16))));if(We(e))return et("0X".concat(BigInt(e).toString(16)));throw new Error(`${e} is not Hex or decimal`)}var tt={};d(tt,{felt:()=>Ot,getAbiContractVersion:()=>Tt,getArrayType:()=>vt,isCairo1Abi:()=>At,isCairo1Type:()=>wt,isLen:()=>ct,isTypeArray:()=>dt,isTypeBool:()=>bt,isTypeContractAddress:()=>Ct,isTypeEnum:()=>ft,isTypeEthAddress:()=>kt,isTypeFelt:()=>lt,isTypeLitteral:()=>_t,isTypeNamedTuple:()=>ht,isTypeOption:()=>gt,isTypeResult:()=>yt,isTypeStruct:()=>pt,isTypeTuple:()=>ut,isTypeUint:()=>mt,isTypeUint256:()=>Et,tuple:()=>St,uint256:()=>It});var nt={};d(nt,{UINT_128_MAX:()=>rt,UINT_256_MAX:()=>at,bnToUint256:()=>ot,isUint256:()=>it,uint256ToBN:()=>st});var rt=(1n<<128n)-1n,at=(1n<<256n)-1n;function st(e){return(we(e.high)<<128n)+we(e.low)}function it(e){return we(e)<=at}function ot(e){const t=we(e);if(!it(t))throw new Error("Number is too large");return{low:A((t&rt).toString(16)),high:A((t>>128n).toString(16))}}var ct=e=>/_len$/.test(e),lt=e=>"felt"===e||"core::felt252"===e,dt=e=>/\*/.test(e)||e.startsWith("core::array::Array::")||e.startsWith("core::array::Span::"),ut=e=>/^\(.*\)$/i.test(e),ht=e=>/\(.*\)/i.test(e)&&e.includes(":"),pt=(e,t)=>e in t,ft=(e,t)=>e in t,gt=e=>e.startsWith("core::option::Option::"),yt=e=>e.startsWith("core::result::Result::"),mt=e=>Object.values(Q).includes(e),_t=e=>Object.values(Z).includes(e),Et=e=>"core::integer::u256"===e,bt=e=>"core::bool"===e,Ct=e=>"core::starknet::contract_address::ContractAddress"===e,kt=e=>"core::starknet::eth_address::EthAddress"===e,wt=e=>e.includes("::"),vt=e=>wt(e)?e.substring(e.indexOf("<")+1,e.lastIndexOf(">")):e.replace("*","");function At(e){const{cairo:t}=Tt(e);if(void 0===t)throw Error("Unable to determine Cairo version");return"1"===t}function Tt(e){if(e.find((e=>"interface"===e.type)))return{cairo:"1",compiler:"2"};const t=e.find((e=>"function"===e.type&&(e.inputs.length||e.outputs.length)));if(!t)return{cairo:void 0,compiler:void 0};const n=t.inputs.length?t.inputs:t.outputs;return wt(n[0].type)?{cairo:"1",compiler:"1"}:{cairo:"0",compiler:"0"}}var It=e=>{const t=BigInt(e);if(!it(t))throw new Error("Number is too large");return{low:(t&rt).toString(10),high:(t>>128n).toString(10)}},St=(...e)=>({...e});function Ot(e){if(ve(e)||"number"===typeof e&&Number.isInteger(e))return e.toString();if(Xe(e)){if(!Ye(e))throw new Error(`${e} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);const t=Ze(e);return BigInt(t).toString()}if("string"===typeof e&&ke(e))return BigInt(e).toString();if("string"===typeof e&&Re(e))return e;if("boolean"===typeof e)return""+ +e;throw new Error(`${e} can't be computed by felt()`)}var Nt=class{constructor(e){const t=Object.values(e);if(0===t.length)throw new Error("This Enum must have a least 1 variant");if(1!==t.filter((e=>"undefined"!==typeof e)).length)throw new Error("This Enum must have exactly one active variant");this.variant=e}unwrap(){const e=Object.entries(this.variant).find((e=>"undefined"!==typeof e[1]));if("undefined"!==typeof e)return e[1]}activeVariant(){const e=Object.entries(this.variant).find((e=>"undefined"!==typeof e[1]));return"undefined"===typeof e?"":e[0]}},xt=(e=>(e[e.Some=0]="Some",e[e.None=1]="None",e))(xt||{}),Dt=class{constructor(e,t){if(!(e in xt))throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");if(0===e){if("undefined"===typeof t)throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');this.Some=t,this.None=void 0}else this.Some=void 0,this.None=!0}unwrap(){if(!this.None)return this.Some}isSome(){return!("undefined"===typeof this.Some)}isNone(){return!0===this.None}},Rt=(e=>(e[e.Ok=0]="Ok",e[e.Err=1]="Err",e))(Rt||{}),Ft=class{constructor(e,t){if(!(e in Rt))throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");0===e?(this.Ok=t,this.Err=void 0):(this.Ok=void 0,this.Err=t)}unwrap(){if("undefined"!==typeof this.Ok)return this.Ok;if("undefined"!==typeof this.Err)return this.Err;throw new Error("Both Result.Ok and .Err are undefined. Not authorized.")}isOk(){return!("undefined"===typeof this.Ok)}isErr(){return!("undefined"===typeof this.Err)}},Pt=(e,t,n)=>{if(!ve(e[n]))throw new Error(`Data and formatter mismatch on ${n}:${t[n]}, expected response data ${n}:${e[n]} to be BN instead it is ${typeof e[n]}`)},Ht=(e,t,n)=>{throw new Error(`Unhandled formatter type on ${n}:${t[n]} for data ${n}:${e[n]}`)};function $t(e,t,n){return Object.entries(e).reduce(((r,[a,s])=>{const i=n??t[a];if(!(a in t)&&!n)return r[a]=s,r;if("string"===i){if(Array.isArray(e[a])){const t=$t(e[a],e[a].map((e=>i)));return r[a]=Object.values(t).join(""),r}return Pt(e,t,a),r[a]=et(s),r}if("number"===i)return Pt(e,t,a),r[a]=Number(s),r;if("function"===typeof i)return r[a]=i(s),r;if(Array.isArray(i)){const t=$t(e[a],i,i[0]);return r[a]=Object.values(t),r}return"object"===typeof i?(r[a]=$t(e[a],i),r):(Ht(e,t,a),r)}),{})}function Lt(e){const t=function(e){return e.find((e=>"interface"===e.type))?2:At(e)?1:0}(e);if(0===t||1===t)return new class{constructor(e){this.abi=e}methodInputsLength(e){return e.inputs.reduce(((e,t)=>ct(t.name)?e:e+1),0)}getMethod(e){return this.abi.find((t=>t.name===e))}getLegacyFormat(){return this.abi}}(e);if(2===t)return new class{constructor(e){this.abi=e}methodInputsLength(e){return e.inputs.length}getMethod(e){return this.abi.find((e=>"interface"===e.type)).items.find((t=>t.name===e))}getLegacyFormat(){return this.abi.flatMap((e=>"interface"===e.type?e.items:e))}}(e);throw Error(`Unsupported ABI version ${t}`)}function Vt(e,t,n){return"constructor"===e&&!n&&!t.length}function Bt(e){if(!e.includes("("))return{subTuple:[],result:e};const t=[];let n="",r=0;for(;r<e.length;){if("("===e[r]){let a=1;const s=r;for(r++;a;)")"===e[r]&&a--,"("===e[r]&&a++,r++;t.push(e.substring(s,r)),n+=" ",r--}else n+=e[r];r++}return{subTuple:t,result:n}}function Ut(e){return wt(e)?function(e){const t=e.replace(/\s/g,"").slice(1,-1),{subTuple:n,result:r}=Bt(t);return r.split(",").map((e=>n.length?e.replace(" ",n.shift()):e))}(e):function(e){const t=e.replace(/\s/g,"").slice(1,-1),{subTuple:n,result:r}=Bt(t);let a=r.split(",").map((e=>n.length?e.replace(" ",n.shift()):e));return ht(e)&&(a=a.reduce(((e,t)=>e.concat(function(e){const t=e.substring(0,e.indexOf(":"));return{name:t,type:e.substring(t.length+":".length)}}(t))),[])),a}(e)}function jt(e,t,n,r){const a=(e,t)=>{if(dt(t))return function(e,t){const n=vt(t);if("string"===typeof e)return e;return e.map((e=>a(e,n)))}(e,t);if(ft(t,r)){const n=r[t];return i(e,n)}if(ut(t))return function(e,t){const n=Ut(t).reduce(((t,n,r)=>{const s=Object.keys(e),i=n=>Object.defineProperty(t,r.toString(),{enumerable:!0,value:n??e[s[r]]}),o=n?.type?n.type:n;return i(a(e[s[r]],o)),t}),{});return n}(e,t);if(kt(t))return e;if(Et(t)){const n=e;if("object"!==typeof n)return n;if(!("low"in n)||!("high"in n))throw Error(`Your object includes the property : ${t}, containing an Uint256 object without the 'low' and 'high' keys.`);return{low:n.low,high:n.high}}if(pt(t,n)){const r=n[t].members;return s(e,r)}return e},s=(e,t)=>t.reduce(((t,n)=>{if("undefined"===e[n.name]&&(wt(n.type)||!ct(n.name)))throw Error(`Your object needs a property with key : ${n.name} .`);var r;return r=a(e[n.name],n.type),Object.defineProperty(t,n.name,{enumerable:!0,value:r??e[n.name]}),t}),{});const i=(e,t)=>{if(yt(t.name)){const n=e,r=t.name.substring(t.name.indexOf("<")+1,t.name.lastIndexOf(",")),s=t.name.substring(t.name.indexOf(",")+1,t.name.lastIndexOf(">"));return n.isOk()?new Ft(0,a(e.unwrap(),r)):new Ft(1,a(e.unwrap(),s))}if(gt(t.name)){const n=e,r=t.name.substring(t.name.indexOf("<")+1,t.name.lastIndexOf(">"));return n.isSome()?new Dt(0,a(n.unwrap(),r)):new Dt(1,{})}const n=e,r=Object.entries(n.variant).map((e=>{if("undefined"===typeof e[1])return e;const r=t.type.substring(t.type.lastIndexOf("<")+1,t.type.lastIndexOf(">"));return"()"===r?e:[e[0],a(n.unwrap(),r)]}));return new Nt(Object.fromEntries(r))};return t.reduce(((t,n)=>{return ct(n.name)&&!wt(n.type)||(r=a(e[n.name],n.type),Object.defineProperty(t,n.name,{enumerable:!0,value:r})),t;var r}),{})}function Mt(e,t){if(!0===Et(e)){const e=It(t);return[Ot(e.low),Ot(e.high)]}return Ot(t)}function Kt(e){if("object"===typeof e){const{low:t,high:n}=e;return[Ot(t),Ot(n)]}const t=It(e);return[Ot(t.low),Ot(t.high)]}function qt(e,t,n,r){if(void 0===e)throw Error(`Missing parameter for type ${t}`);if(Array.isArray(e)){const a=[];a.push(Ot(e.length));const s=vt(t);return e.reduce(((e,t)=>e.concat(qt(t,s,n,r))),a)}if(n[t]&&n[t].members.length){if(Et(t))return Kt(e);if("core::starknet::eth_address::EthAddress"===t)return Mt(t,e);const{members:a}=n[t],s=e;return a.reduce(((e,t)=>e.concat(qt(s[t.name],t.type,n,r))),[])}if(ut(t)){const a=function(e,t){const n=Ut(t),r=Object.values(e);if(r.length!==n.length)throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${r} \n      expected: ${n}`);return n.map(((e,t)=>({element:r[t],type:e.type??e})))}(e,t);return a.reduce(((e,t)=>{const a=qt(t.element,t.type,n,r);return e.concat(a)}),[])}if(Et(t))return Kt(e);if(ft(t,r)){const{variants:a}=r[t];if(gt(t)){const t=e;if(t.isSome()){const e=a.find((e=>"Some"===e.name));if("undefined"===typeof e)throw Error("Error in abi : Option has no 'Some' variant.");const s=e.type;if("()"===s)return(0).toString();const i=qt(t.unwrap(),s,n,r);return Array.isArray(i)?[(0).toString(),...i]:[(0).toString(),i]}return 1..toString()}if(yt(t)){const t=e;if(t.isOk()){const e=a.find((e=>"Ok"===e.name));if("undefined"===typeof e)throw Error("Error in abi : Result has no 'Ok' variant.");const s=e.type;if("()"===s)return(0).toString();const i=qt(t.unwrap(),s,n,r);return Array.isArray(i)?[(0).toString(),...i]:[(0).toString(),i]}const s=a.find((e=>"Err"===e.name));if("undefined"===typeof s)throw Error("Error in abi : Result has no 'Err' variant.");const i=s.type;if("()"===i)return 1..toString();const o=qt(t.unwrap(),i,n,r);return Array.isArray(o)?[1..toString(),...o]:[1..toString(),o]}const s=e,i=s.activeVariant(),o=a.find((e=>e.name===i));if("undefined"===typeof o)throw Error(`Not find in abi : Enum has no '${i}' variant.`);const c=o.type,l=a.findIndex((e=>e.name===i));if("()"===c)return l.toString();const d=qt(s.unwrap(),c,n,r);return Array.isArray(d)?[l.toString(),...d]:[l.toString(),d]}if("object"===typeof e)throw Error(`Parameter ${e} do not align with abi parameter ${t}`);return Mt(t,e)}function Gt(e,t){let n;switch(!0){case bt(e):return n=t.next().value,Boolean(BigInt(n));case Et(e):return st({low:t.next().value,high:t.next().value});default:return n=t.next().value,BigInt(n)}}function Yt(e,t,n,r){if("()"===t.type)return{};if(Et(t.type)){return st({low:e.next().value,high:e.next().value})}if(dt(t.type)){const a=[],s={name:"",type:vt(t.type)},i=BigInt(e.next().value);for(;a.length<i;)a.push(Yt(e,s,n,r));return a}if(n&&t.type in n&&n[t.type])return"core::starknet::eth_address::EthAddress"===t.type?Gt(t.type,e):n[t.type].members.reduce(((t,a)=>(t[a.name]=Yt(e,a,n,r),t)),{});if(r&&t.type in r&&r[t.type]){const a=Number(e.next().value),s=r[t.type].variants.reduce(((t,s,i)=>i===a?(t[s.name]=Yt(e,{name:"",type:s.type},n,r),t):(t[s.name]=void 0,t)),{});if(t.type.startsWith("core::option::Option")){const e=0===a?s.Some:void 0;return new Dt(a,e)}if(t.type.startsWith("core::result::Result")){let e;return e=0===a?s.Ok:s.Err,new Ft(a,e)}return new Nt(s)}if(ut(t.type)){return Ut(t.type).reduce(((t,a,s)=>{const i=a?.name?a.name:s,o={name:i,type:a?.type?a.type:a};return t[i]=Yt(e,o,n,r),t}),{})}if(dt(t.type)){const a=[],s={name:"",type:vt(t.type)},i=BigInt(e.next().value);for(;a.length<i;)a.push(Yt(e,s,n,r));return a}return Gt(t.type,e)}function Wt(e,t,n,r,a){const{name:s,type:i}=t;let o;switch(!0){case ct(s):return o=e.next().value,BigInt(o);case n&&i in n||ut(i):case r&&ft(i,r):return Yt(e,t,n,r);case dt(i):if(wt(i))return Yt(e,t,n,r);const c=[];if(a&&a[`${s}_len`]){const i=a[`${s}_len`];for(;c.length<i;)c.push(Yt(e,{name:s,type:t.type.replace("*","")},n,r))}return c;default:return Gt(i,e)}}var Xt=(e,t)=>{if(Ee("string"===typeof e||"number"===typeof e||"bigint"===typeof e,`Validate: arg ${t.name} should be a felt typed as (String, Number or BigInt)`),"string"===typeof e&&!ke(e))return;const n=BigInt(e.toString(10));Ee(n>=0n&&n<=2n**252n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^252-1]`)},Jt=(e,t)=>{"number"===typeof e&&Ee(e<=Number.MAX_SAFE_INTEGER,"Validation: Parameter is to large to be typed as Number use (BigInt or String)"),Ee("string"===typeof e||"number"===typeof e||"bigint"===typeof e||"object"===typeof e&&"low"in e&&"high"in e,`Validate: arg ${t.name} of cairo type ${t.type} should be type (String, Number or BigInt), but is ${typeof e} ${e}.`);const n="object"===typeof e?st(e):we(e);switch(t.type){case"core::integer::u8":Ee(n>=0n&&n<=255n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0 - 255]`);break;case"core::integer::u16":Ee(n>=0n&&n<=65535n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 65535]`);break;case"core::integer::u32":Ee(n>=0n&&n<=4294967295n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 4294967295]`);break;case"core::integer::u64":Ee(n>=0n&&n<=2n**64n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^64-1]`);break;case"core::integer::u128":Ee(n>=0n&&n<=2n**128n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^128-1]`);break;case"core::integer::u256":Ee(n>=0n&&n<=2n**256n-1n,`Validate: arg ${t.name} is ${t.type} 0 - 2^256-1`);break;case"core::starknet::class_hash::ClassHash":case"core::starknet::contract_address::ContractAddress":Ee(n>=0n&&n<=2n**252n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^252-1]`)}},zt=(e,t)=>{Ee("boolean"===typeof e,`Validate: arg ${t.name} of cairo type ${t.type} should be type (Boolean)`)},Qt=(e,t,n)=>{if("core::integer::u256"!==t.type)if("core::starknet::eth_address::EthAddress"!==t.type)Ee("object"===typeof e&&!Array.isArray(e),`Validate: arg ${t.name} is cairo type struct (${t.type}), and should be defined as js object (not array)`),n[t.type].members.forEach((({name:n})=>{Ee(Object.keys(e).includes(n),`Validate: arg ${t.name} should have a property ${n}`)}));else{Ee("object"!==typeof e,`EthAdress type is waiting a BigNumberish. Got ${e}`);const n=BigInt(e.toString(10));Ee(n>=0n&&n<=2n**160n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^160-1]`)}else Jt(e,t)},Zt=(e,t)=>{Ee("object"===typeof e&&!Array.isArray(e),`Validate: arg ${t.name} is cairo type Enum (${t.type}), and should be defined as js object (not array)`);const n=Object.getOwnPropertyNames(Object.getPrototypeOf(e)),r=[...Object.getOwnPropertyNames(e),...n];if(!(gt(t.type)&&r.includes("isSome")&&r.includes("isNone"))&&!(yt(t.type)&&r.includes("isOk")&&r.includes("isErr"))&&(!r.includes("variant")||!r.includes("activeVariant")))throw new Error(`Validate Enum: argument ${t.name}, type ${t.type}, value received ${e}, is not an Enum.`)},en=(e,t)=>{Ee("object"===typeof e&&!Array.isArray(e),`Validate: arg ${t.name} should be a tuple (defined as object)`)},tn=(e,t,n,r)=>{const a=vt(t.type);if(!lt(a)||!ze(e))switch(Ee(Array.isArray(e),`Validate: arg ${t.name} should be an Array`),!0){case lt(a):e.forEach((e=>Xt(e,t)));break;case ut(a):e.forEach((e=>en(e,{name:t.name,type:a})));break;case dt(a):e.forEach((e=>tn(e,{name:"",type:a},n,r)));break;case pt(a,n):e.forEach((e=>Qt(e,{name:t.name,type:a},n)));break;case ft(a,r):e.forEach((e=>Zt(e,{name:t.name,type:a})));break;case mt(a)||_t(a):e.forEach((e=>Jt(e,t)));break;case bt(a):e.forEach((e=>zt(e,t)));break;default:throw new Error(`Validate Unhandled: argument ${t.name}, type ${t.type}, value ${e}`)}};function nn(e,t,n,r){e.inputs.reduce(((e,a)=>{const s=t[e];switch(!0){case ct(a.name):return e;case lt(a.type):Xt(s,a);break;case mt(a.type)||_t(a.type):Jt(s,a);break;case bt(a.type):zt(s,a);break;case dt(a.type):tn(s,a,n,r);break;case pt(a.type,n):Qt(s,a,n);break;case ft(a.type,r):Zt(s,a);break;case ut(a.type):en(s,a);break;default:throw new Error(`Validate Unhandled: argument ${a.name}, type ${a.type}, value ${s}`)}return e+1}),0)}var rn=class{constructor(e){this.structs=rn.getAbiStruct(e),this.enums=rn.getAbiEnum(e),this.parser=Lt(e),this.abi=this.parser.getLegacyFormat()}validate(e,t,n=[]){if("DEPLOY"!==e){Ee(this.abi.filter((t=>{if("function"!==t.type)return!1;const n="view"===t.stateMutability||"view"===t.state_mutability;return"INVOKE"===e?!n:n})).map((e=>e.name)).includes(t),("INVOKE"===e?"invocable":"viewable")+" method not found in abi")}const r=this.abi.find((n=>"DEPLOY"===e?n.name===t&&"constructor"===n.type:n.name===t&&"function"===n.type));if(Vt(t,n,r))return;const a=this.parser.methodInputsLength(r);if(n.length!==a)throw Error(`Invalid number of arguments, expected ${a} arguments, but got ${n.length}`);nn(r,n,this.structs,this.enums)}compile(e,t){const n=this.abi.find((t=>t.name===e));if(Vt(e,t,n))return[];let r;if(Array.isArray(t))r=t;else{const e=jt(t,n.inputs,this.structs,this.enums);r=Object.values(e),nn(n,r,this.structs,this.enums)}const a=r[Symbol.iterator](),s=n.inputs.reduce(((e,t)=>ct(t.name)&&!wt(t.type)?e:e.concat(function(e,t,n,r){const{name:a,type:s}=t;let{value:i}=e.next();switch(!0){case dt(s):if(!Array.isArray(i)&&!Xe(i))throw Error(`ABI expected parameter ${a} to be array or long string, got ${i}`);return"string"===typeof i&&(i=Qe(i)),qt(i,t.type,n,r);case"core::starknet::eth_address::EthAddress"===s:return Mt(s,i);case pt(s,n)||ut(s)||Et(s):case ft(s,r):return qt(i,s,n,r);default:return Mt(s,i)}}(a,t,this.structs,this.enums))),[]);return Object.defineProperty(s,"__compiled__",{enumerable:!1,writable:!1,value:!0}),s}static compile(e){const t=e=>{const t=(e,n=".")=>{const r=Array.isArray(e)?[e.length.toString(),...e]:e;return Object.entries(r).flatMap((([e,a])=>{let s=a;ze(s)&&(s=Qe(s)),"entrypoint"===e&&(s=Me(s));const i=Array.isArray(r)&&"0"===e?"$$len":e;if(ve(s))return[[`${n}${i}`,Ot(s)]];if(Object(s)===s){const e=Object.getOwnPropertyNames(Object.getPrototypeOf(s)),r=[...Object.getOwnPropertyNames(s),...e];if(r.includes("isSome")&&r.includes("isNone")){const e=s,r=e.isSome()?0:1;return e.isSome()?t({0:r,1:e.unwrap()},`${n}${i}.`):[[`${n}${i}`,Ot(r)]]}if(r.includes("isOk")&&r.includes("isErr")){const e=s,r=e.isOk()?0:1;return t({0:r,1:e.unwrap()},`${n}${i}.`)}if(r.includes("variant")&&r.includes("activeVariant")){const e=s,r=e.activeVariant(),a=Object.keys(e.variant).findIndex((e=>e===r));return"object"===typeof e.unwrap()&&0===Object.keys(e.unwrap()).length?[[`${n}${i}`,Ot(a)]]:t({0:a,1:e.unwrap()},`${n}${i}.`)}return t(s,`${n}${i}.`)}return[[`${n}${i}`,Ot(s)]]}))};return Object.fromEntries(t(e))};let n;if(Array.isArray(e)){const r=t({...e});n=Object.values(r)}else{const r=t(e);n=Object.values(r)}return Object.defineProperty(n,"__compiled__",{enumerable:!1,writable:!1,value:!0}),n}parse(e,t){const{outputs:n}=this.abi.find((t=>t.name===e)),r=t.flat()[Symbol.iterator](),a=n.flat().reduce(((e,t,n)=>{const a=t.name??n;return e[a]=Wt(r,t,this.structs,this.enums,e),e[a]&&e[`${a}_len`]&&delete e[`${a}_len`],e}),{});return 1===Object.keys(a).length&&0 in a?a[0]:a}format(e,t,n){return $t(this.parse(e,t),n)}static getAbiStruct(e){return e.filter((e=>"struct"===e.type)).reduce(((e,t)=>({...e,[t.name]:t})),{})}static getAbiEnum(e){const t=e.filter((e=>"enum"===e.type)).reduce(((e,t)=>({...e,[t.name]:t})),{});return delete t["core::bool"],t}static toCalldata(e=[]){return rn.compile(e)}static toHex(e=[]){return rn.compile(e).map((e=>Ae(e)))}},an={};d(an,{calculateContractAddressFromHash:()=>On,calculateDeclareTransactionHash:()=>Tn,calculateDeployAccountTransactionHash:()=>In,calculateDeployTransactionHash:()=>An,calculateTransactionHash:()=>Sn,calculateTransactionHashCommon:()=>vn,computeCompiledClassHash:()=>Pn,computeContractClassHash:()=>Ln,computeHashOnElements:()=>wn,computeLegacyContractClassHash:()=>Rn,computeSierraContractClassHash:()=>$n,default:()=>Dn,feeTransactionVersion:()=>bn,feeTransactionVersion_2:()=>Cn,formatSpaces:()=>xn,getSelector:()=>Ke,getSelectorFromName:()=>Me,getVersionsByType:()=>kn,keccakBn:()=>Ue,poseidon:()=>mn,starknetKeccak:()=>je,transactionVersion:()=>_n,transactionVersion_2:()=>En});var sn=n(37962),on={};d(on,{starkCurve:()=>cn,weierstrass:()=>ln});var cn=h(n(37962)),ln=h(n(96551)),dn={};d(dn,{parse:()=>pn,parseAlwaysAsBig:()=>fn,stringify:()=>gn,stringifyAlwaysAsBig:()=>yn});var un=h(n(30484)),hn=e=>{if(!un.isInteger(e))return parseFloat(e);const t=parseInt(e,10);return Number.isSafeInteger(t)?t:BigInt(e)},pn=e=>un.parse(String(e),void 0,hn),fn=e=>un.parse(String(e),void 0,un.parseNumberAndBigInt),gn=(e,t,n,r)=>un.stringify(e,t,n,r),yn=gn,mn=h(n(33192)),_n=F,En=P,bn=H,Cn=$;function kn(e){return"fee"===e?{v1:bn,v2:Cn}:{v1:_n,v2:En}}function wn(e){return[...e,e.length].reduce(((e,t)=>cn.pedersen(we(e),we(t))),0).toString()}function vn(e,t,n,r,a,s,i,o=[]){const c=wn(a);return wn([e,t,n,r,c,s,i,...o])}function An(e,t,n,r,a="constructor"){return vn("0x6465706c6f79",n,e,Me(a),t,0,r)}function Tn(e,t,n,r,a,s,i){return vn("0x6465636c617265",n,t,0,[e],r,a,[s,...i?[i]:[]])}function In(e,t,n,r,a,s,i,o){return vn("0x6465706c6f795f6163636f756e74",a,e,0,[t,r,...n],s,i,[o])}function Sn(e,t,n,r,a,s){return vn("0x696e766f6b65",t,e,0,n,r,a,[s])}function On(e,t,n,r){const a=wn(rn.compile(n));return wn([Ot("0x535441524b4e45545f434f4e54524143545f41444452455353"),r,e,t,a])}function Nn(e,t){return"attributes"===e||"accessible_scopes"===e?Array.isArray(t)&&0===t.length?void 0:t:"debug_info"===e?null:null===t?void 0:t}function xn(e){let t=!1;const n=[];for(const r of e)'"'===r&&!1===(n.length>0&&"\\"===n.slice(-1)[0])&&(t=!t),t?n.push(r):n.push(":"===r?": ":","===r?", ":r);return n.join("")}function Dn(e){const{abi:t,program:n}=e,r=xn(gn({abi:t,program:n},Nn));return A(cn.keccak(E(r)).toString(16))}function Rn(e){const t="string"===typeof e?pn(e):e,n=Ae(U),r=wn(t.entry_points_by_type.EXTERNAL.flatMap((e=>[e.selector,e.offset]))),a=wn(t.entry_points_by_type.L1_HANDLER.flatMap((e=>[e.selector,e.offset]))),s=wn(t.entry_points_by_type.CONSTRUCTOR.flatMap((e=>[e.selector,e.offset]))),i=wn(t.program.builtins.map((e=>Ze(e)))),o=Dn(t),c=wn(t.program.data);return wn([n,r,a,s,i,o,c])}function Fn(e){const t=e.flatMap((e=>{return[BigInt(e.selector),BigInt(e.offset),(t=e.builtins,(0,sn.poseidonHashMany)(t.flatMap((e=>BigInt(Ze(e))))))];var t}));return(0,sn.poseidonHashMany)(t)}function Pn(e){const t=BigInt(Ze("COMPILED_CLASS_V1")),n=Fn(e.entry_points_by_type.EXTERNAL),r=Fn(e.entry_points_by_type.L1_HANDLER),a=Fn(e.entry_points_by_type.CONSTRUCTOR),s=(0,sn.poseidonHashMany)(e.bytecode.map((e=>BigInt(e))));return Ae((0,sn.poseidonHashMany)([t,n,r,a,s]))}function Hn(e){const t=e.flatMap((e=>[BigInt(e.selector),BigInt(e.function_idx)]));return(0,sn.poseidonHashMany)(t)}function $n(e){const t=BigInt(Ze("CONTRACT_CLASS_V0.1.0")),n=Hn(e.entry_points_by_type.EXTERNAL),r=Hn(e.entry_points_by_type.L1_HANDLER),a=Hn(e.entry_points_by_type.CONSTRUCTOR),s=function(e){const t=xn(gn(e.abi,null));return BigInt(A(cn.keccak(E(t)).toString(16)))}(e),i=(0,sn.poseidonHashMany)(e.sierra_program.map((e=>BigInt(e))));return Ae((0,sn.poseidonHashMany)([t,n,r,a,s,i]))}function Ln(e){const t="string"===typeof e?pn(e):e;return"sierra_program"in t?$n(t):Rn(t)}var Vn={};d(Vn,{compressProgram:()=>jn,decompressProgram:()=>Mn,estimatedFeeToMaxFee:()=>Xn,formatSignature:()=>Gn,makeAddress:()=>qn,randomAddress:()=>Kn,signatureToDecimalArray:()=>Yn,signatureToHexArray:()=>Wn});var Bn=n(37962),Un=n(99591);function jn(e){const t="string"===typeof e?e:gn(e);return k((0,Un.gzip)(t))}function Mn(e){if(Array.isArray(e))return e;const t=_((0,Un.ungzip)(C(e)));return pn(t)}function Kn(){const e=Bn.utils.randomPrivateKey();return(0,Bn.getStarkKey)(e)}function qn(e){return A(e).toLowerCase()}function Gn(e){if(!e)throw Error("formatSignature: provided signature is undefined");if(Array.isArray(e))return e.map((e=>Ae(e)));try{const{r:t,s:n}=e;return[Ae(t),Ae(n)]}catch(t){throw new Error("Signature need to be weierstrass.SignatureType or an array for custom")}}function Yn(e){return xe(Gn(e))}function Wn(e){return De(Gn(e))}function Xn(e,t=.5){const n=Math.round(100*(1+t));return we(e)*we(n)/100n}function Jn(e){return"sierra_program"in("string"===typeof e?pn(e):e)}function zn(e){const t={...e};if(Jn(e.contract)&&(!e.compiledClassHash&&e.casm&&(t.compiledClassHash=Pn(e.casm)),!t.compiledClassHash))throw new Error("Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash");if(t.classHash=e.classHash??Ln(e.contract),!t.classHash)throw new Error("Extract classHash failed, provide (CompiledContract).json file or classHash");return t}function Qn(e){if(Jn(e))throw Error("ContractClassResponse need to be LegacyContractClass (cairo0 response class)");const t=e;return{...t,program:Mn(t.program)}}var Zn=h(n(94301)),er="undefined"!==typeof window&&window.fetch||"undefined"!==typeof n.g&&n.g.fetch||Zn.default,tr={};function nr(e){return new Promise((t=>{setTimeout(t,e)}))}function rr(e){const t={...e};return delete t.sierra_program_debug_info,t.abi=xn(gn(e.abi)),t.sierra_program=xn(gn(e.sierra_program)),t.sierra_program=jn(t.sierra_program),t}function ar(e){const t="string"===typeof e?pn(e):e;return Jn(e)?rr(t):{...t,..."program"in t&&{program:jn(t.program)}}}d(tr,{createSierraContractClass:()=>rr,parseContract:()=>ar,wait:()=>nr});function sr(e,t=e.constructor){const{captureStackTrace:n}=Error;n&&n(e,t)}function ir(e,t){const{setPrototypeOf:n}=Object;n?n(e,t):e.__proto__=t}var or=class extends Error{constructor(e){super(e),Object.defineProperty(this,"name",{value:new.target.name,enumerable:!1,configurable:!0}),ir(this,new.target.prototype),sr(this)}},cr=class extends or{},lr=class extends cr{constructor(e,t){super(e),this.errorCode=t}},dr=class extends cr{constructor(e,t){super(e),this.errorCode=t}},ur={};d(ur,{StarknetIdContract:()=>Cr,getStarknetIdContract:()=>kr,useDecoded:()=>Er,useEncoded:()=>br});var hr="abcdefghijklmnopqrstuvwxyz0123456789-",pr=BigInt(hr.length+1),fr="\u8fd9\u6765",gr=BigInt(hr.length),yr=BigInt(fr.length),mr=BigInt(fr.length+1);function _r(e){let t=0;for(;e.endsWith(fr[fr.length-1]);)e=e.substring(0,e.length-1),t+=1;return[e,t]}function Er(e){let t="";return e.forEach((e=>{for(;e!==L;){const n=e%pr;if(e/=pr,n===BigInt(hr.length)){const n=e/mr;if(n===L){const r=e%mr;e=n,t+=r===L?hr[0]:fr[Number(r)-1]}else{t+=fr[Number(e%yr)],e/=yr}}else t+=hr[Number(n)]}const[n,r]=_r(t);r&&(t=n+(r%2===0?fr[fr.length-1].repeat(r/2-1)+fr[0]+hr[1]:fr[fr.length-1].repeat((r-1)/2+1))),t+="."})),t?t.concat("stark"):t}function br(e){let t=BigInt(0),n=BigInt(1);if(e.endsWith(fr[0]+hr[1])){const[t,n]=_r(e.substring(0,e.length-2));e=t+fr[fr.length-1].repeat(2*(n+1))}else{const[t,n]=_r(e);n&&(e=t+fr[fr.length-1].repeat(1+2*(n-1)))}for(let r=0;r<e.length;r+=1){const a=e[r],s=hr.indexOf(a),i=BigInt(hr.indexOf(a));if(-1!==s)r===e.length-1&&e[r]===hr[0]?(t+=n*gr,n*=pr,n*=pr):(t+=n*i,n*=pr);else if(-1!==fr.indexOf(a)){t+=n*gr,n*=pr;const s=(r===e.length-1?1:0)+fr.indexOf(a);t+=n*BigInt(s),n*=yr}}return t}var Cr=(e=>(e.MAINNET="0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678",e.TESTNET="0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce",e))(Cr||{});function kr(e){switch(e){case"0x534e5f4d41494e":return"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";case"0x534e5f474f45524c49":return"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce";default:throw new Error("Starknet.id is not yet deployed on this network")}}async function wr(e,t,n){const r=await e.getChainId(),a=n??kr(r);try{const n=await e.callContract({contractAddress:a,entrypoint:"address_to_domain",calldata:rn.compile({address:t})}),r=Er(n.result.map((e=>BigInt(e))).slice(1));if(!r)throw Error("Starkname not found");return r}catch(s){if(s instanceof Error&&"Starkname not found"===s.message)throw s;throw Error("Could not get stark name")}}async function vr(e,t,n){const r=await e.getChainId(),a=n??kr(r);try{return(await e.callContract({contractAddress:a,entrypoint:"domain_to_address",calldata:rn.compile({domain:[br(t.replace(".stark","")).toString(10)]})})).result[0]}catch{throw Error("Could not get address from stark name")}}var Ar=Object.values(ie),Tr=class{constructor(e){this.hash=null,this.number=null,this.tag=null,this.valueOf=()=>this.number,this.toString=()=>this.hash,this.setIdentifier(e)}setIdentifier(e){"string"===typeof e&&ke(e)?this.hash=e:"bigint"===typeof e?this.hash=Ae(e):"number"===typeof e?this.number=e:"string"===typeof e&&Ar.includes(e)?this.tag=e:this.tag="pending"}get queryIdentifier(){return null!==this.number?`blockNumber=${this.number}`:null!==this.hash?`blockHash=${this.hash}`:`blockNumber=${this.tag}`}get identifier(){return null!==this.number?{block_number:this.number}:null!==this.hash?{block_hash:this.hash}:this.tag}set identifier(e){this.setIdentifier(e)}get sequencerIdentifier(){return null!==this.hash?{blockHash:this.hash}:{blockNumber:this.number??this.tag}}},Ir=(e,t=!1)=>{t||console.warn("Using default public node url, please provide nodeUrl in provider options!");const n="SN_MAIN"===e?W:Y;return n[Math.floor(Math.random()*n.length)]},Sr={"Content-Type":"application/json"},Or="pending",Nr=200,xr=class{constructor(e){this.responseParser=new class{parseGetBlockResponse(e){return{timestamp:e.timestamp,block_hash:"block_hash"in e?e.block_hash:"",block_number:"block_number"in e?e.block_number:-1,new_root:"new_root"in e?e.new_root:"",parent_hash:e.parent_hash,status:"status"in e?e.status:"PENDING",transactions:e.transactions}}parseGetTransactionResponse(e){return{calldata:"calldata"in e?e.calldata:[],contract_address:"contract_address"in e?e.contract_address:"",sender_address:"sender_address"in e?e.sender_address:"",max_fee:"max_fee"in e?e.max_fee:"",nonce:"nonce"in e?e.nonce:"",signature:"signature"in e?e.signature:[],transaction_hash:e.transaction_hash,version:e.version}}parseFeeEstimateResponse(e){return{overall_fee:we(e[0].overall_fee),gas_consumed:we(e[0].gas_consumed),gas_price:we(e[0].gas_price)}}parseFeeEstimateBulkResponse(e){return e.map((e=>({overall_fee:we(e.overall_fee),gas_consumed:we(e.gas_consumed),gas_price:we(e.gas_price)})))}parseCallContractResponse(e){return{result:e}}parseSimulateTransactionResponse(e){return e.map((e=>({...e,suggestedMaxFee:Xn(BigInt(e.fee_estimation.overall_fee))})))}parseContractClassResponse(e){return{...e,abi:"string"===typeof e.abi?JSON.parse(e.abi):e.abi}}},this.getBlockHashAndNumber=this.getBlockLatestAccepted,this.getStateUpdate=this.getBlockStateUpdate,this.traceBlockTransactions=this.getBlockTransactionsTraces,this.getTransactionCount=this.getBlockTransactionCount,this.traceTransaction=this.getTransactionTrace,this.getSimulateTransaction=this.simulateTransaction;const{nodeUrl:t,retries:n,headers:r,blockIdentifier:a,chainId:s}=e||{};Object.values(M).includes(t)?this.nodeUrl=Ir(t,e?.default):this.nodeUrl=t||Ir(void 0,e?.default),this.retries=n||Nr,this.headers={...Sr,...r},this.blockIdentifier=a||Or,this.chainId=s}fetch(e,t,n=0){const r={id:n,jsonrpc:"2.0",method:e,...t&&{params:t}};return er(this.nodeUrl,{method:"POST",body:gn(r),headers:this.headers})}errorHandler(e,t,n,r){if(n){const{code:r,message:a,data:s}=n;throw new cr(`RPC: ${e} with params ${gn(t)}\n ${r}: ${a}: ${gn(s)}`)}if(r instanceof cr)throw r;if(r)throw Error(r.message)}async fetchEndpoint(e,t){try{const n=await this.fetch(e,t),{error:r,result:a}=await n.json();return this.errorHandler(e,t,r),a}catch(n){throw this.errorHandler(e,t,n?.response?.data,n),n}}async getChainId(){return this.chainId??(this.chainId=await this.fetchEndpoint("starknet_chainId")),this.chainId}async getSpecVersion(){return this.fetchEndpoint("starknet_specVersion")}async getNonceForAddress(e,t=this.blockIdentifier){const n=Ae(e),r=new Tr(t).identifier;return this.fetchEndpoint("starknet_getNonce",{contract_address:n,block_id:r})}async getBlock(e=this.blockIdentifier){return this.getBlockWithTxHashes(e).then(this.responseParser.parseGetBlockResponse)}async getBlockLatestAccepted(){return this.fetchEndpoint("starknet_blockHashAndNumber")}async getBlockNumber(){return this.fetchEndpoint("starknet_blockNumber")}async getBlockWithTxHashes(e=this.blockIdentifier){const t=new Tr(e).identifier;return this.fetchEndpoint("starknet_getBlockWithTxHashes",{block_id:t})}async getBlockWithTxs(e=this.blockIdentifier){const t=new Tr(e).identifier;return this.fetchEndpoint("starknet_getBlockWithTxs",{block_id:t})}async getBlockStateUpdate(e=this.blockIdentifier){const t=new Tr(e).identifier;return this.fetchEndpoint("starknet_getStateUpdate",{block_id:t})}async getBlockTransactionsTraces(e=this.blockIdentifier){const t=new Tr(e).identifier;return this.fetchEndpoint("starknet_traceBlockTransactions",{block_id:t})}async getBlockTransactionCount(e=this.blockIdentifier){const t=new Tr(e).identifier;return this.fetchEndpoint("starknet_getBlockTransactionCount",{block_id:t})}async getPendingTransactions(){const{transactions:e}=await this.getBlock("pending");return Promise.all(e.map((e=>this.getTransactionByHash(e))))}async getTransaction(e){return this.getTransactionByHash(e).then(this.responseParser.parseGetTransactionResponse)}async getTransactionByHash(e){const t=Ae(e);return this.fetchEndpoint("starknet_getTransactionByHash",{transaction_hash:t})}async getTransactionByBlockIdAndIndex(e,t){const n=new Tr(e).identifier;return this.fetchEndpoint("starknet_getTransactionByBlockIdAndIndex",{block_id:n,index:t})}async getTransactionReceipt(e){const t=Ae(e);return this.fetchEndpoint("starknet_getTransactionReceipt",{transaction_hash:t})}async getTransactionTrace(e){const t=Ae(e);return this.fetchEndpoint("starknet_traceTransaction",{transaction_hash:t})}async getTransactionStatus(e){const t=Ae(e);return this.fetchEndpoint("starknet_getTransactionStatus",{transaction_hash:t})}async simulateTransaction(e,{blockIdentifier:t=this.blockIdentifier,skipValidate:n=!1,skipFeeCharge:r=!0}){const a=new Tr(t).identifier,s=[];return n&&s.push(oe.ESimulationFlag.SKIP_VALIDATE),r&&s.push(oe.ESimulationFlag.SKIP_FEE_CHARGE),this.fetchEndpoint("starknet_simulateTransactions",{block_id:a,transactions:e.map((e=>this.buildTransaction(e))),simulation_flags:s}).then(this.responseParser.parseSimulateTransactionResponse)}async waitForTransaction(e,t){const n=Ae(e);let{retries:r}=this,a=!1,s=!1;const i=t?.retryInterval??5e3,o=t?.errorStates??[oe.ETransactionStatus.REJECTED,oe.ETransactionExecutionStatus.REVERTED],c=t?.successStates??[oe.ETransactionExecutionStatus.SUCCEEDED,oe.ETransactionStatus.ACCEPTED_ON_L2,oe.ETransactionStatus.ACCEPTED_ON_L1];let l;for(;!a;){await nr(i);try{l=await this.getTransactionStatus(n);const e=l.execution_status,t=l.finality_status;if(!t){throw new Error("waiting for transaction status")}if(c.includes(e)||c.includes(t))a=!0;else if(o.includes(e)||o.includes(t)){const n=`${e}: ${t}`,r=new Error(n);throw r.response=l,s=!0,r}}catch(u){if(u instanceof Error&&s)throw u;if(r<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}r-=1}let d=null;for(;null===d;){try{d=await this.getTransactionReceipt(n)}catch(u){if(r<=0)throw new Error(`waitForTransaction timed-out with retries ${this.retries}`)}r-=1,await nr(i)}return d}async getStorageAt(e,t,n=this.blockIdentifier){const r=Ae(e),a=Ie(t),s=new Tr(n).identifier;return this.fetchEndpoint("starknet_getStorageAt",{contract_address:r,key:a,block_id:s})}async getClassHashAt(e,t=this.blockIdentifier){const n=Ae(e),r=new Tr(t).identifier;return this.fetchEndpoint("starknet_getClassHashAt",{block_id:r,contract_address:n})}async getClassByHash(e){return this.getClass(e)}async getClass(e,t=this.blockIdentifier){const n=Ae(e),r=new Tr(t).identifier;return this.fetchEndpoint("starknet_getClass",{class_hash:n,block_id:r}).then(this.responseParser.parseContractClassResponse)}async getClassAt(e,t=this.blockIdentifier){const n=Ae(e),r=new Tr(t).identifier;return this.fetchEndpoint("starknet_getClassAt",{block_id:r,contract_address:n}).then(this.responseParser.parseContractClassResponse)}async getCode(e,t){throw new Error("RPC does not implement getCode function")}async getContractVersion(e,t,{blockIdentifier:n=this.blockIdentifier,compiler:r=!0}={}){let a;if(e)a=await this.getClassAt(e,n);else{if(!t)throw Error("getContractVersion require contractAddress or classHash");a=await this.getClass(t,n)}if(Jn(a)){if(r){return{cairo:"1",compiler:Tt(a.abi).compiler}}return{cairo:"1",compiler:void 0}}return{cairo:"0",compiler:"0"}}async getEstimateFee(e,t,n=this.blockIdentifier){return this.getInvokeEstimateFee(e,t,n)}async getInvokeEstimateFee(e,t,n=this.blockIdentifier){const r=new Tr(n).identifier,a=this.buildTransaction({type:"INVOKE_FUNCTION",...e,...t},"fee");return this.fetchEndpoint("starknet_estimateFee",{request:[a],block_id:r}).then(this.responseParser.parseFeeEstimateResponse)}async getDeclareEstimateFee(e,t,n=this.blockIdentifier){const r=new Tr(n).identifier,a=this.buildTransaction({type:"DECLARE",...e,...t},"fee");return this.fetchEndpoint("starknet_estimateFee",{request:[a],block_id:r}).then(this.responseParser.parseFeeEstimateResponse)}async getDeployAccountEstimateFee(e,t,n=this.blockIdentifier){const r=new Tr(n).identifier,a=this.buildTransaction({type:"DEPLOY_ACCOUNT",...e,...t},"fee");return this.fetchEndpoint("starknet_estimateFee",{request:[a],block_id:r}).then(this.responseParser.parseFeeEstimateResponse)}async getEstimateFeeBulk(e,{blockIdentifier:t=this.blockIdentifier,skipValidate:n=!1}){n&&console.warn("getEstimateFeeBulk RPC does not support skipValidate");const r=new Tr(t).identifier;return this.fetchEndpoint("starknet_estimateFee",{request:e.map((e=>this.buildTransaction(e,"fee"))),block_id:r}).then(this.responseParser.parseFeeEstimateBulkResponse)}async invokeFunction(e,t){return this.fetchEndpoint("starknet_addInvokeTransaction",{invoke_transaction:{sender_address:e.contractAddress,calldata:rn.toHex(e.calldata),type:oe.ETransactionType.INVOKE,max_fee:Ae(t.maxFee||0),version:"0x1",signature:Wn(e.signature),nonce:Ae(t.nonce)}})}async declareContract({contract:e,signature:t,senderAddress:n,compiledClassHash:r},a){return Jn(e)?this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:oe.ETransactionType.DECLARE,contract_class:{sierra_program:Mn(e.sierra_program),contract_class_version:e.contract_class_version,entry_points_by_type:e.entry_points_by_type,abi:e.abi},compiled_class_hash:r||"",version:R,max_fee:Ae(a.maxFee||0),signature:Wn(t),sender_address:n,nonce:Ae(a.nonce)}}):this.fetchEndpoint("starknet_addDeclareTransaction",{declare_transaction:{type:oe.ETransactionType.DECLARE,contract_class:{program:e.program,entry_points_by_type:e.entry_points_by_type,abi:e.abi},version:D,max_fee:Ae(a.maxFee||0),signature:Wn(t),sender_address:n,nonce:Ae(a.nonce)}})}async deployAccountContract({classHash:e,constructorCalldata:t,addressSalt:n,signature:r},a){return this.fetchEndpoint("starknet_addDeployAccountTransaction",{deploy_account_transaction:{constructor_calldata:rn.toHex(t||[]),class_hash:Ae(e),contract_address_salt:Ae(n||0),type:oe.ETransactionType.DEPLOY_ACCOUNT,max_fee:Ae(a.maxFee||0),version:Ae(a.version||0),signature:Wn(r),nonce:Ae(a.nonce)}})}async callContract(e,t=this.blockIdentifier){const n=new Tr(t).identifier,r=await this.fetchEndpoint("starknet_call",{request:{contract_address:e.contractAddress,entry_point_selector:Me(e.entrypoint),calldata:rn.toHex(e.calldata)},block_id:n});return this.responseParser.parseCallContractResponse(r)}async estimateMessageFee(e,t=this.blockIdentifier){const{from_address:n,to_address:r,entry_point_selector:a,payload:s}=e,i={from_address:Ae(n),to_address:Ae(r),entry_point_selector:Ke(a),payload:He(s)},o=new Tr(t).identifier;return this.fetchEndpoint("starknet_estimateMessageFee",{message:i,block_id:o})}async getSyncingStats(){return this.fetchEndpoint("starknet_syncing")}async getEvents(e){return this.fetchEndpoint("starknet_getEvents",{filter:e})}async getStarkName(e,t){return wr(this,e,t)}async getAddressFromStarkName(e,t){return vr(this,e,t)}buildTransaction(e,t){const n=kn(t),r={signature:Wn(e.signature),nonce:Ae(e.nonce),max_fee:Ae(e.maxFee||0)};if("INVOKE_FUNCTION"===e.type)return{type:oe.ETransactionType.INVOKE,sender_address:e.contractAddress,calldata:rn.toHex(e.calldata),version:Ae(e.version||n.v1),...r};if("DECLARE"===e.type)return Jn(e.contract)?{type:e.type,contract_class:{...e.contract,sierra_program:Mn(e.contract.sierra_program)},compiled_class_hash:e.compiledClassHash||"",sender_address:e.senderAddress,version:Ae(e.version||n.v2),...r}:{type:e.type,contract_class:e.contract,sender_address:e.senderAddress,version:Ae(e.version||n.v1),...r};if("DEPLOY_ACCOUNT"===e.type)return{type:e.type,constructor_calldata:rn.toHex(e.constructorCalldata||[]),class_hash:Ae(e.classHash),contract_address_salt:Ae(e.addressSalt||0),version:Ae(e.version||n.v1),...r};throw Error("RPC buildTransaction received unknown TransactionType")}},Dr=h(n(34078)),Rr=h(n(34078)),Fr=/^(?:\w+:)?\/\/(\S+)$/,Pr=/^localhost[:?\d]*(?:[^:?\d]\S*)?$/,Hr=/^[^\s.]+\.\S{2,}$/;function $r(e){if(!e)return!1;if("string"!==typeof e)return!1;const t=e.match(Fr);if(!t)return!1;const n=t[1];return!!n&&!(!Pr.test(n)&&!Hr.test(n))}function Lr(e,t,n){return $r(n)?n:(0,Rr.default)(e,n??t)}var Vr={network:"SN_GOERLI",blockIdentifier:"pending"},Br=class{constructor(e=Vr){this.responseParser=new class extends class{}{parseGetBlockResponse(e){return{...e,new_root:e.state_root,parent_hash:e.parent_block_hash,transactions:Object.values(e.transactions).map((e=>"transaction_hash"in e&&e.transaction_hash)).filter(Boolean)}}parseGetTransactionResponse(e){if("NOT_RECEIVED"===e.status&&"NOT_RECEIVED"===e.finality_status)throw new cr;return{...e,calldata:"calldata"in e.transaction?e.transaction.calldata:[],contract_class:"contract_class"in e.transaction?e.transaction.contract_class:void 0,entry_point_selector:"entry_point_selector"in e.transaction?e.transaction.entry_point_selector:void 0,max_fee:"max_fee"in e.transaction?e.transaction.max_fee:void 0,nonce:e.transaction.nonce,sender_address:"sender_address"in e.transaction?e.transaction.sender_address:void 0,signature:"signature"in e.transaction?e.transaction.signature:void 0,transaction_hash:"transaction_hash"in e.transaction?e.transaction.transaction_hash:void 0,version:"version"in e.transaction?e.transaction.version:void 0}}parseGetTransactionReceiptResponse(e){return{...e,messages_sent:e.l2_to_l1_messages,..."revert_error"in e&&{revert_reason:e.revert_error}}}parseFeeEstimateResponse(e){if("overall_fee"in e){let t={};try{t={gas_consumed:we(e.gas_usage),gas_price:we(e.gas_price)}}catch{}return{overall_fee:we(e.overall_fee),...t}}return{overall_fee:we(e.amount)}}parseFeeEstimateBulkResponse(e){return[].concat(e).map((e=>{if("overall_fee"in e){let t={};try{t={gas_consumed:we(e.gas_usage),gas_price:we(e.gas_price)}}catch{}return{overall_fee:we(e.overall_fee),...t}}return{overall_fee:we(e.amount)}}))}parseSimulateTransactionResponse(e){const t="overall_fee"in e.fee_estimation?e.fee_estimation.overall_fee:e.fee_estimation.amount;return[{transaction_trace:e.trace,fee_estimation:e.fee_estimation,suggestedMaxFee:Xn(BigInt(t))}]}parseCallContractResponse(e){return{result:e.result}}parseInvokeFunctionResponse(e){return{transaction_hash:e.transaction_hash}}parseDeployContractResponse(e){return{transaction_hash:e.transaction_hash,contract_address:e.address}}parseDeclareContractResponse(e){return{transaction_hash:e.transaction_hash,class_hash:e.class_hash}}parseGetStateUpdateResponse(e){const t=Object.entries(e.state_diff.nonces).map((([e,t])=>({contract_address:e,nonce:t}))),n=Object.entries(e.state_diff.storage_diffs).map((([e,t])=>({address:e,storage_entries:t})));return{...e,state_diff:{...e.state_diff,storage_diffs:n,nonces:t}}}parseContractClassResponse(e){const t=Jn(e)?e:ar(e);return{...t,abi:"string"===typeof t.abi?JSON.parse(t.abi):t.abi}}},"network"in e?(this.baseUrl=Br.getNetworkFromName(e.network),this.feederGatewayUrl=Lr(this.baseUrl,"feeder_gateway"),this.gatewayUrl=Lr(this.baseUrl,"gateway")):(this.baseUrl=e.baseUrl,this.feederGatewayUrl=Lr(this.baseUrl,"feeder_gateway",e.feederGatewayUrl),this.gatewayUrl=Lr(this.baseUrl,"gateway",e.gatewayUrl)),this.chainId=e?.chainId??Br.getChainIdFromBaseUrl(this.baseUrl),this.headers=e.headers,this.blockIdentifier=e?.blockIdentifier||Vr.blockIdentifier}static getNetworkFromName(e){switch(e){case"SN_MAIN":case"0x534e5f4d41494e":return"https://alpha-mainnet.starknet.io";case"SN_GOERLI":case"0x534e5f474f45524c49":return"https://alpha4.starknet.io";default:throw new Error("Could not detect base url from NetworkName")}}static getChainIdFromBaseUrl(e){try{return new URL(e).host.includes("mainnet.starknet.io")?"0x534e5f4d41494e":"0x534e5f474f45524c49"}catch{return console.error(`Could not parse baseUrl: ${e}`),"0x534e5f474f45524c49"}}getFetchUrl(e){return["add_transaction"].includes(e)?this.gatewayUrl:this.feederGatewayUrl}getFetchMethod(e){return["add_transaction","call_contract","estimate_fee","estimate_message_fee","estimate_fee_bulk","simulate_transaction"].includes(e)?"POST":"GET"}getQueryString(e){if(void 0===(t=e)||0===Object.keys(t).length||1===Object.keys(t).length&&Object.entries(t).every((([e,t])=>"blockIdentifier"===e&&null===t)))return"";var t;return`?${Object.entries(e).map((([e,t])=>{if("blockIdentifier"===e){return`${new Tr(t).queryIdentifier}`}return`${e}=${t}`})).join("&")}`}getHeaders(e){return"POST"===e?{"Content-Type":"application/json",...this.headers}:this.headers}async fetchEndpoint(e,...[t,n]){const r=this.getFetchUrl(e),a=this.getFetchMethod(e),s=this.getQueryString(t),i=(0,Dr.default)(r,e,s);return this.fetch(i,{method:a,body:n})}async fetch(e,t){const n=Lr(this.baseUrl,"",e),r=t?.method??"GET",a=this.getHeaders(r),s=gn(t?.body);try{const e=await er(n,{method:r,body:s,headers:a}),i=await e.text();if(!e.ok){let t;try{t=pn(i)}catch{throw new dr(e.statusText,e.status)}throw new lr(t.message,t.code)}return(t?.parseAlwaysAsBigInt?fn:pn)(i)}catch(i){if(i instanceof Error&&!(i instanceof cr))throw Error(`Could not ${r} from endpoint \`${n}\`: ${i.message}`);throw i}}async getChainId(){return Promise.resolve(this.chainId)}async callContract({contractAddress:e,entrypoint:t,calldata:n=[]},r=this.blockIdentifier){return this.fetchEndpoint("call_contract",{blockIdentifier:r},{contract_address:e,entry_point_selector:Me(t),calldata:rn.compile(n)}).then(this.responseParser.parseCallContractResponse)}async getBlock(e=this.blockIdentifier){return this.fetchEndpoint("get_block",{blockIdentifier:e}).then(this.responseParser.parseGetBlockResponse)}async getNonceForAddress(e,t=this.blockIdentifier){return this.fetchEndpoint("get_nonce",{contractAddress:e,blockIdentifier:t})}async getStorageAt(e,t,n=this.blockIdentifier){const r=we(t).toString(10);return this.fetchEndpoint("get_storage_at",{blockIdentifier:n,contractAddress:e,key:r})}async getTransaction(e){const t=Ae(e);return this.fetchEndpoint("get_transaction",{transactionHash:t}).then((e=>{if(1===Object.values(e).length)throw new cr(e.status);return this.responseParser.parseGetTransactionResponse(e)}))}async getTransactionReceipt(e){const t=Ae(e);return this.fetchEndpoint("get_transaction_receipt",{transactionHash:t}).then(this.responseParser.parseGetTransactionReceiptResponse)}async getClassAt(e,t=this.blockIdentifier){return this.fetchEndpoint("get_full_contract",{blockIdentifier:t,contractAddress:e}).then(this.responseParser.parseContractClassResponse)}async getClassHashAt(e,t=this.blockIdentifier){return this.fetchEndpoint("get_class_hash_at",{blockIdentifier:t,contractAddress:e})}async getClassByHash(e,t=this.blockIdentifier){return this.fetchEndpoint("get_class_by_hash",{classHash:e,blockIdentifier:t}).then(this.responseParser.parseContractClassResponse)}async getCompiledClassByClassHash(e,t=this.blockIdentifier){return this.fetchEndpoint("get_compiled_class_by_class_hash",{classHash:e,blockIdentifier:t})}async getContractVersion(e,t,{blockIdentifier:n=this.blockIdentifier,compiler:r=!0}={}){let a;if(e)a=await this.getClassAt(e,n);else{if(!t)throw Error("getContractVersion require contractAddress or classHash");a=await this.getClassByHash(t,n)}if(Jn(a)){if(r){return{cairo:"1",compiler:Tt(a.abi).compiler}}return{cairo:"1",compiler:void 0}}return{cairo:"0",compiler:"0"}}async invokeFunction(e,t){return this.fetchEndpoint("add_transaction",void 0,{type:"INVOKE_FUNCTION",sender_address:e.contractAddress,calldata:rn.compile(e.calldata??[]),signature:Yn(e.signature),nonce:Ae(t.nonce),max_fee:Ae(t.maxFee||0),version:"0x1"}).then(this.responseParser.parseInvokeFunctionResponse)}async deployAccountContract({classHash:e,constructorCalldata:t,addressSalt:n,signature:r},a){return this.fetchEndpoint("add_transaction",void 0,{type:"DEPLOY_ACCOUNT",contract_address_salt:n??Kn(),constructor_calldata:rn.compile(t??[]),class_hash:Ae(e),max_fee:Ae(a.maxFee||0),version:Ae(a.version||0),nonce:Ae(a.nonce),signature:Yn(r)}).then(this.responseParser.parseDeployContractResponse)}async declareContract({senderAddress:e,contract:t,signature:n,compiledClassHash:r},a){return Jn(t)?this.fetchEndpoint("add_transaction",void 0,{type:"DECLARE",sender_address:e,compiled_class_hash:r,contract_class:t,nonce:Ae(a.nonce),signature:Yn(n),max_fee:Ae(a.maxFee||0),version:Ae(En)}).then(this.responseParser.parseDeclareContractResponse):this.fetchEndpoint("add_transaction",void 0,{type:"DECLARE",contract_class:t,nonce:Ae(a.nonce),signature:Yn(n),sender_address:e,max_fee:Ae(a.maxFee||0),version:Ae(_n)}).then(this.responseParser.parseDeclareContractResponse)}async getEstimateFee(e,t,n=this.blockIdentifier,r=!1){return this.getInvokeEstimateFee(e,t,n,r)}async getInvokeEstimateFee(e,t,n=this.blockIdentifier,r=!1){const a=this.buildTransaction({type:"INVOKE_FUNCTION",...e,...t},"fee");return this.fetchEndpoint("estimate_fee",{blockIdentifier:n,skipValidate:r},a).then(this.responseParser.parseFeeEstimateResponse)}async getDeclareEstimateFee(e,t,n=this.blockIdentifier,r=!1){const a=this.buildTransaction({type:"DECLARE",...e,...t},"fee");return this.fetchEndpoint("estimate_fee",{blockIdentifier:n,skipValidate:r},a).then(this.responseParser.parseFeeEstimateResponse)}async getDeployAccountEstimateFee(e,t,n=this.blockIdentifier,r=!1){const a=this.buildTransaction({type:"DEPLOY_ACCOUNT",...e,...t},"fee");return this.fetchEndpoint("estimate_fee",{blockIdentifier:n,skipValidate:r},a).then(this.responseParser.parseFeeEstimateResponse)}async getEstimateFeeBulk(e,{blockIdentifier:t=this.blockIdentifier,skipValidate:n=!1}){const r=e.map((e=>this.buildTransaction(e,"fee")));return this.fetchEndpoint("estimate_fee_bulk",{blockIdentifier:t,skipValidate:n},r).then(this.responseParser.parseFeeEstimateBulkResponse)}async getCode(e,t=this.blockIdentifier){return this.fetchEndpoint("get_code",{contractAddress:e,blockIdentifier:t})}async waitForTransaction(e,t){let n,r=!1,a=0;const s=t?.retryInterval??5e3,i=t?.errorStates??["REJECTED","NOT_RECEIVED","REVERTED"],o=t?.successStates??["SUCCEEDED","ACCEPTED_ON_L1","ACCEPTED_ON_L2"];for(;!r;)if(await nr(s),n=await this.getTransactionStatus(e),"NOT_RECEIVED"===n.finality_status&&a<3)a+=1;else if(o.includes(n.finality_status)||o.includes(n.execution_status))r=!0;else if(i.includes(n.finality_status)||i.includes(n.execution_status)){let e;e=n.tx_failure_reason?`${n.tx_status}: ${n.tx_failure_reason.code}\n${n.tx_failure_reason.error_message}`:n.tx_revert_reason?`${n.tx_status}: ${n.tx_revert_reason}`:n.tx_status;const t=new Error(e);throw t.response=n,t}return await this.getTransactionReceipt(e)}async getTransactionStatus(e){const t=Ae(e);return this.fetchEndpoint("get_transaction_status",{transactionHash:t})}async getContractAddresses(){return this.fetchEndpoint("get_contract_addresses")}async getTransactionTrace(e){const t=Ae(e);return this.fetchEndpoint("get_transaction_trace",{transactionHash:t})}async estimateMessageFee({from_address:e,to_address:t,entry_point_selector:n,payload:r},a=this.blockIdentifier){const s={from_address:Fe(e),to_address:Pe(t),entry_point_selector:Ke(n),payload:He(r)};return this.fetchEndpoint("estimate_message_fee",{blockIdentifier:a},s)}async getSimulateTransaction(e,{blockIdentifier:t=this.blockIdentifier,skipValidate:n=!1,skipExecute:r=!1}){e.length>1&&console.warn("Sequencer simulate process only first element from invocations list"),r&&console.warn("Sequencer can't skip account __execute__");const a=this.buildTransaction(e[0]);return this.fetchEndpoint("simulate_transaction",{blockIdentifier:t,skipValidate:n??!1},a).then(this.responseParser.parseSimulateTransactionResponse)}async getStateUpdate(e=this.blockIdentifier){const t=new Tr(e).sequencerIdentifier;return this.fetchEndpoint("get_state_update",{...t}).then(this.responseParser.parseGetStateUpdateResponse)}async getBlockTraces(e=this.blockIdentifier){const t=new Tr(e).sequencerIdentifier;return this.fetchEndpoint("get_block_traces",{...t})}async getStarkName(e,t){return wr(this,e,t)}async getAddressFromStarkName(e,t){return vr(this,e,t)}buildTransaction(e,t){const n=kn(t),r={signature:Yn(e.signature),nonce:Ae(e.nonce)};if("INVOKE_FUNCTION"===e.type)return{type:e.type,sender_address:e.contractAddress,calldata:rn.compile(e.calldata??[]),version:Ae(e.version||n.v1),...r};if("DECLARE"===e.type)return Jn(e.contract)?{type:e.type,contract_class:e.contract,compiled_class_hash:e.compiledClassHash,sender_address:e.senderAddress,version:Ae(e.version||n.v2),...r}:{type:e.type,contract_class:e.contract,sender_address:e.senderAddress,version:Ae(e.version||n.v1),...r};if("DEPLOY_ACCOUNT"===e.type)return{type:e.type,constructor_calldata:rn.compile(e.constructorCalldata||[]),class_hash:Ae(e.classHash),contract_address_salt:Ae(e.addressSalt||0),version:Ae(e.version||n.v1),...r};throw Error("Sequencer buildTransaction received unknown TransactionType")}},Ur=class{constructor(e){this.provider=e instanceof Ur?e.provider:e instanceof xr||e instanceof Br?e:e&&"rpc"in e?new xr(e.rpc):e&&"sequencer"in e?new Br(e.sequencer):new xr}async getChainId(){return this.provider.getChainId()}async getBlock(e){return this.provider.getBlock(e)}async getClassAt(e,t){return this.provider.getClassAt(e,t)}async getClassHashAt(e,t){return this.provider.getClassHashAt(e,t)}getClassByHash(e){return this.provider.getClassByHash(e)}async getEstimateFee(e,t,n){return this.provider.getEstimateFee(e,t,n)}async getInvokeEstimateFee(e,t,n,r){return this.provider.getInvokeEstimateFee(e,t,n,r)}async getEstimateFeeBulk(e,t){return this.provider.getEstimateFeeBulk(e,t)}async getNonceForAddress(e,t){return this.provider.getNonceForAddress(e,t)}async getStorageAt(e,t,n){return this.provider.getStorageAt(e,t,n)}async getTransaction(e){return this.provider.getTransaction(e)}async getTransactionReceipt(e){return this.provider.getTransactionReceipt(e)}async callContract(e,t){return this.provider.callContract(e,t)}async invokeFunction(e,t){return this.provider.invokeFunction(e,t)}async deployAccountContract(e,t){return this.provider.deployAccountContract(e,t)}async declareContract(e,t){return this.provider.declareContract(e,t)}async getDeclareEstimateFee(e,t,n,r){return this.provider.getDeclareEstimateFee(e,t,n,r)}getDeployAccountEstimateFee(e,t,n,r){return this.provider.getDeployAccountEstimateFee(e,t,n,r)}async getCode(e,t){return this.provider.getCode(e,t)}async waitForTransaction(e,t){return this.provider.waitForTransaction(e,t)}async getSimulateTransaction(e,t){return this.provider.getSimulateTransaction(e,t)}async getStateUpdate(e){return this.provider.getStateUpdate(e)}async getStarkName(e,t){return wr(this,e,t)}async getAddressFromStarkName(e,t){return vr(this,e,t)}async getContractVersion(e,t,n){return this.provider.getContractVersion(e,t,n)}},jr=class{},Mr={};d(Mr,{fromCallsToExecuteCalldata:()=>qr,fromCallsToExecuteCalldataWithNonce:()=>Gr,fromCallsToExecuteCalldata_cairo1:()=>Wr,getExecuteCalldata:()=>Xr,transformCallsToMulticallArrays:()=>Kr,transformCallsToMulticallArrays_cairo1:()=>Yr});var Kr=e=>{const t=[],n=[];return e.forEach((e=>{const r=rn.compile(e.calldata||[]);t.push({to:we(e.contractAddress).toString(10),selector:we(Me(e.entrypoint)).toString(10),data_offset:n.length.toString(),data_len:r.length.toString()}),n.push(...r)})),{callArray:t,calldata:rn.compile({calldata:n})}},qr=e=>{const{callArray:t,calldata:n}=Kr(e);return[...rn.compile({callArray:t}),...n]},Gr=(e,t)=>[...qr(e),we(t).toString()],Yr=e=>e.map((e=>({to:we(e.contractAddress).toString(10),selector:we(Me(e.entrypoint)).toString(10),calldata:rn.compile(e.calldata||[])}))),Wr=e=>{const t=e.map((e=>({contractAddress:e.contractAddress,entrypoint:e.entrypoint,calldata:Array.isArray(e.calldata)&&"__compiled__"in e.calldata?e.calldata:rn.compile(e.calldata)})));return rn.compile({orderCalls:t})},Xr=(e,t="0")=>"1"===t?Wr(e):qr(e),Jr={};d(Jr,{encodeData:()=>oa,encodeType:()=>aa,encodeValue:()=>ia,getDependencies:()=>ra,getMessageHash:()=>la,getStructHash:()=>ca,getTypeHash:()=>sa,isMerkleTreeType:()=>na,prepareSelector:()=>ta});var zr={};d(zr,{MerkleTree:()=>Qr,proofMerklePath:()=>Zr});var Qr=class{constructor(e){this.branches=[],this.leaves=e,this.root=this.build(e)}build(e){if(1===e.length)return e[0];e.length!==this.leaves.length&&this.branches.push(e);const t=[];for(let n=0;n<e.length;n+=2)n+1===e.length?t.push(Qr.hash(e[n],"0x0")):t.push(Qr.hash(e[n],e[n+1]));return this.build(t)}static hash(e,t){const[n,r]=[we(e),we(t)].sort(((e,t)=>e>=t?1:-1));return cn.pedersen(n,r)}getProof(e,t=this.leaves,n=[]){const r=t.indexOf(e);if(-1===r)throw new Error("leaf not found");if(1===t.length)return n;const a=r%2===0,s=(a?t[r+1]:t[r-1])??"0x0",i=[...n,s],o=this.leaves.length===t.length?-1:this.branches.findIndex((e=>e.length===t.length)),c=this.branches[o+1]??[this.root];return this.getProof(Qr.hash(a?e:s,a?s:e),c,i)}};function Zr(e,t,n){if(0===n.length)return e===t;const[r,...a]=n;return Zr(e,Qr.hash(t,r),a)}function ea(e){try{return Ae(e)}catch(t){if("string"===typeof e)return Ae(Ze(e));throw new Error(`Invalid BigNumberish: ${e}`)}}function ta(e){return ke(e)?e:Me(e)}function na(e){return"merkletree"===e.type}var ra=(e,t,n=[])=>("*"===t[t.length-1]&&(t=t.slice(0,-1)),n.includes(t)?n:e[t]?[t,...e[t].reduce(((t,n)=>[...t,...ra(e,n.type,t).filter((e=>!t.includes(e)))]),[])]:n);var aa=(e,t)=>{const[n,...r]=ra(e,t);return(n?[n,...r.sort()]:[]).map((t=>`${t}(${e[t].map((e=>`${e.name}:${e.type}`))})`)).join("")},sa=(e,t)=>Me(aa(e,t)),ia=(e,t,n,r={})=>{if(e[t])return[t,ca(e,t,n)];if(Object.keys(e).map((e=>`${e}*`)).includes(t)){const r=n.map((n=>ca(e,t.slice(0,-1),n)));return[t,wn(r)]}if("merkletree"===t){const t=function(e,t){if(t.parent&&t.key){const n=e[t.parent].find((e=>e.name===t.key));if(!na(n))throw new Error(`${t.key} is not a merkle tree`);if(n.contains.endsWith("*"))throw new Error(`Merkle tree contain property must not be an array but was given ${t.key}`);return n.contains}return"raw"}(e,r),a=n.map((n=>ia(e,t,n)[1])),{root:s}=new Qr(a);return["felt",s]}return"felt*"===t?["felt*",wn(n)]:"selector"===t?["felt",ta(n)]:[t,ea(n)]},oa=(e,t,n)=>{const[r,a]=e[t].reduce((([r,a],s)=>{if(void 0===n[s.name]||null===n[s.name])throw new Error(`Cannot encode data: missing data for '${s.name}'`);const i=n[s.name],[o,c]=ia(e,s.type,i,{parent:t,key:s.name});return[[...r,o],[...a,c]]}),[["felt"],[sa(e,t)]]);return[r,a]},ca=(e,t,n)=>wn(oa(e,t,n)[1]),la=(e,t)=>{if(!(e=>{const t=e;return Boolean(t.types&&t.primaryType&&t.message)})(e))throw new Error("Typed data does not match JSON schema");return wn([Ze("StarkNet Message"),ca(e.types,"StarkNetDomain",e.domain),t,ca(e.types,e.primaryType,e.message)])},da=class{constructor(e=cn.utils.randomPrivateKey()){this.pk=e instanceof Uint8Array?w(e):Ae(e)}async getPubKey(){return cn.getStarkKey(this.pk)}async signMessage(e,t){const n=la(e,t);return cn.sign(n,this.pk)}async signTransaction(e,t,n){if(n&&n.length!==e.length)throw new Error("ABI must be provided for each transaction or no transaction");const r=Xr(e,t.cairoVersion),a=Sn(t.walletAddress,t.version,r,t.maxFee,t.chainId,t.nonce);return cn.sign(a,this.pk)}async signDeployAccountTransaction({classHash:e,contractAddress:t,constructorCalldata:n,addressSalt:r,maxFee:a,version:s,chainId:i,nonce:o}){const c=In(t,e,rn.compile(n),r,s,a,i,o);return cn.sign(c,this.pk)}async signDeclareTransaction({classHash:e,senderAddress:t,chainId:n,maxFee:r,version:a,nonce:s,compiledClassHash:i}){const o=Tn(e,t,a,r,n,s,i);return cn.sign(o,this.pk)}};function ua(e){if(!e.events)throw new Error("UDC emitted event is empty");const t=e.events.find((e=>Oe(e.from_address)===Oe(G.ADDRESS)))||{data:[]};return{transaction_hash:e.transaction_hash,contract_address:t.data[0],address:t.data[0],deployer:t.data[1],unique:t.data[2],classHash:t.data[3],calldata_len:t.data[4],calldata:t.data.slice(5,5+parseInt(t.data[4],16)),salt:t.data[t.data.length-1]}}var ha=class extends Ur{constructor(e,t,n,r){super(e),this.deploySelf=this.deployAccount,this.address=t.toLowerCase(),this.signer="string"===typeof n||n instanceof Uint8Array?new da(n):n,r&&(this.cairoVersion=r.toString())}async getNonce(e){return super.getNonceForAddress(this.address,e)}async getNonceSafe(e){try{return we(e??await this.getNonce())}catch(t){return 0n}}async getCairoVersion(e){if(!this.cairoVersion){const{cairo:t}=e?await super.getContractVersion(void 0,e):await super.getContractVersion(this.address);this.cairoVersion=t}return this.cairoVersion}async estimateFee(e,t){return this.estimateInvokeFee(e,t)}async estimateInvokeFee(e,{nonce:t,blockIdentifier:n,skipValidate:r}={}){const a=Array.isArray(e)?e:[e],s=we(t??await this.getNonce()),i=we(bn),o=await this.getChainId(),c={walletAddress:this.address,nonce:s,maxFee:L,version:i,chainId:o,cairoVersion:await this.getCairoVersion()},l=await this.buildInvocation(a,c),d=await super.getInvokeEstimateFee({...l},{version:i,nonce:s},n,r),u=Xn(d.overall_fee);return{...d,suggestedMaxFee:u}}async estimateDeclareFee({contract:e,classHash:t,casm:n,compiledClassHash:r},{blockIdentifier:a,nonce:s,skipValidate:i}={}){const o=we(s??await this.getNonce()),c=Jn(e)?Cn:bn,l=await this.getChainId(),d=await this.buildDeclarePayload({classHash:t,contract:e,casm:n,compiledClassHash:r},{nonce:o,chainId:l,version:c,walletAddress:this.address,maxFee:L,cairoVersion:void 0}),u=await super.getDeclareEstimateFee(d,{version:c,nonce:o},a,i),h=Xn(u.overall_fee);return{...u,suggestedMaxFee:h}}async estimateAccountDeployFee({classHash:e,addressSalt:t=0,constructorCalldata:n=[],contractAddress:r},{blockIdentifier:a,skipValidate:s}={}){const i=we(bn),o=L,c=await this.getChainId(),l=await this.buildAccountDeployPayload({classHash:e,addressSalt:t,constructorCalldata:n,contractAddress:r},{nonce:o,chainId:c,version:i,walletAddress:this.address,maxFee:L,cairoVersion:void 0}),d=await super.getDeployAccountEstimateFee({...l},{version:i,nonce:o},a,s),u=Xn(d.overall_fee);return{...d,suggestedMaxFee:u}}async estimateDeployFee(e,t){const n=this.buildUDCContractPayload(e);return this.estimateInvokeFee(n,t)}async estimateFeeBulk(e,{nonce:t,blockIdentifier:n,skipValidate:r}={}){const a=await this.accountInvocationsFactory(e,{versions:[bn,Cn],nonce:t,blockIdentifier:n}),s=await super.getEstimateFeeBulk(a,{blockIdentifier:n,skipValidate:r});return[].concat(s).map((e=>{const t=Xn(e.overall_fee);return{...e,suggestedMaxFee:t}}))}async buildInvocation(e,t){const n=Xr(e,await this.getCairoVersion()),r=await this.signer.signTransaction(e,t);return{contractAddress:this.address,calldata:n,signature:r}}async execute(e,t,n={}){const r=Array.isArray(e)?e:[e],a=we(n.nonce??await this.getNonce()),s=n.maxFee??await this.getSuggestedMaxFee({type:"INVOKE_FUNCTION",payload:e},n),i=we(_n),o=await this.getChainId(),c={walletAddress:this.address,nonce:a,maxFee:s,version:i,chainId:o,cairoVersion:await this.getCairoVersion()},l=await this.signer.signTransaction(r,c,t),d=Xr(r,await this.getCairoVersion());return this.invokeFunction({contractAddress:this.address,calldata:d,signature:l},{nonce:a,maxFee:s,version:i})}async declareIfNot(e,t={}){const n=zn(e);try{await this.getClassByHash(n.classHash)}catch(r){return this.declare(e,t)}return{transaction_hash:"",class_hash:n.classHash}}async declare(e,t={}){const n=zn(e),r={};r.nonce=we(t.nonce??await this.getNonce()),r.maxFee=t.maxFee??await this.getSuggestedMaxFee({type:"DECLARE",payload:n},t),r.version=Jn(e.contract)?En:_n,r.chainId=await this.getChainId();const a=await this.buildDeclarePayload(n,{...r,walletAddress:this.address,cairoVersion:void 0});return this.declareContract(a,r)}async deploy(e,t){const n=[].concat(e).map((e=>{const{classHash:t,salt:n,unique:r=!0,constructorCalldata:a=[]}=e,s=rn.compile(a),i=n??Kn();return{call:{contractAddress:G.ADDRESS,entrypoint:G.ENTRYPOINT,calldata:[t,i,$e(r),s.length,...s]},address:On(r?cn.pedersen(this.address,i):i,t,s,r?G.ADDRESS:0)}})),r=n.map((e=>e.call)),a=n.map((e=>e.address));return{...await this.execute(r,void 0,t),contract_address:a}}async deployContract(e,t){const n=await this.deploy(e,t);return ua(await this.waitForTransaction(n.transaction_hash))}async declareAndDeploy(e,t){const{constructorCalldata:n,salt:r,unique:a}=e;let s=await this.declareIfNot(e,t);if(""!==s.transaction_hash){const e=await this.waitForTransaction(s.transaction_hash);s={...s,...e}}const i=await this.deployContract({classHash:s.class_hash,salt:r,unique:a,constructorCalldata:n},t);return{declare:{...s},deploy:i}}async deployAccount({classHash:e,constructorCalldata:t=[],addressSalt:n=0,contractAddress:r},a={}){const s=we(_n),i=L,o=await this.getChainId(),c=rn.compile(t),l=r??On(n,e,c,0),d=a.maxFee??await this.getSuggestedMaxFee({type:"DEPLOY_ACCOUNT",payload:{classHash:e,constructorCalldata:c,addressSalt:n,contractAddress:l}},a),u=await this.signer.signDeployAccountTransaction({classHash:e,constructorCalldata:c,contractAddress:l,addressSalt:n,chainId:o,maxFee:d,version:s,nonce:i});return this.deployAccountContract({classHash:e,addressSalt:n,constructorCalldata:t,signature:u},{nonce:i,maxFee:d,version:s})}async signMessage(e){return this.signer.signMessage(e,this.address)}async hashMessage(e){return la(e,this.address)}async verifyMessageHash(e,t){try{return await this.callContract({contractAddress:this.address,entrypoint:"isValidSignature",calldata:rn.compile({hash:we(e).toString(),signature:Gn(t)})}),!0}catch{return!1}}async verifyMessage(e,t){const n=await this.hashMessage(e);return this.verifyMessageHash(n,t)}async getSuggestedMaxFee({type:e,payload:t},n){let r;switch(e){case"INVOKE_FUNCTION":r=await this.estimateInvokeFee(t,n);break;case"DECLARE":r=await this.estimateDeclareFee(t,n);break;case"DEPLOY_ACCOUNT":r=await this.estimateAccountDeployFee(t,n);break;case"DEPLOY":r=await this.estimateDeployFee(t,n);break;default:r={suggestedMaxFee:L,overall_fee:L}}return r.suggestedMaxFee}async buildDeclarePayload(e,{nonce:t,chainId:n,version:r,walletAddress:a,maxFee:s}){const{classHash:i,contract:o,compiledClassHash:c}=zn(e),l=ar(o);return{senderAddress:a,signature:await this.signer.signDeclareTransaction({classHash:i,compiledClassHash:c,senderAddress:a,chainId:n,maxFee:s,version:r,nonce:t}),contract:l,compiledClassHash:c}}async buildAccountDeployPayload({classHash:e,addressSalt:t=0,constructorCalldata:n=[],contractAddress:r},{nonce:a,chainId:s,version:i,maxFee:o}){const c=rn.compile(n),l=r??On(t,e,c,0);return{classHash:e,addressSalt:t,constructorCalldata:c,signature:await this.signer.signDeployAccountTransaction({classHash:e,contractAddress:l,chainId:s,maxFee:o,version:i,nonce:a,addressSalt:t,constructorCalldata:c})}}buildUDCContractPayload(e){return[].concat(e).map((e=>{const{classHash:t,salt:n="0",unique:r=!0,constructorCalldata:a=[]}=e,s=rn.compile(a);return{contractAddress:G.ADDRESS,entrypoint:G.ENTRYPOINT,calldata:[t,n,$e(r),s.length,...s]}}))}async simulateTransaction(e,{nonce:t,blockIdentifier:n,skipValidate:r,skipExecute:a}={}){const s=await this.accountInvocationsFactory(e,{versions:[_n,En],nonce:t,blockIdentifier:n});return super.getSimulateTransaction(s,{blockIdentifier:n,skipValidate:r,skipExecute:a})}async accountInvocationsFactory(e,{versions:t,nonce:n,blockIdentifier:r}){const a=t[0],s=await this.getNonceSafe(n),i=await this.getChainId(),o="payload"in e[0]?e[0].payload:e[0],c="DEPLOY_ACCOUNT"===e[0].type?await this.getCairoVersion(o.classHash):await this.getCairoVersion();return Promise.all([].concat(e).map((async(e,n)=>{const o="payload"in e?e.payload:e,l={walletAddress:this.address,nonce:we(Number(s)+n),maxFee:L,version:a,chainId:i,cairoVersion:c},d={type:e.type,version:a,nonce:we(Number(s)+n),blockIdentifier:r};if("INVOKE_FUNCTION"===e.type){const e=await this.buildInvocation([].concat(o),l);return{...d,...e}}if("DECLARE"===e.type){l.version=Jn(o.contract)?we(t[1]):we(t[0]);const e=await this.buildDeclarePayload(o,l);return{...d,...e,version:l.version}}if("DEPLOY_ACCOUNT"===e.type){const e=await this.buildAccountDeployPayload(o,l);return{...d,...e}}if("DEPLOY"===e.type){const e=this.buildUDCContractPayload(o),t=await this.buildInvocation(e,l);return{...d,...t,type:"INVOKE_FUNCTION"}}throw Error(`accountInvocationsFactory: unsupported transaction type: ${e}`)})))}async getStarkName(e=this.address,t){return super.getStarkName(e,t)}},pa=class{},fa=new Ur({rpc:{default:!0}}),ga=class extends pa{},ya={};function ma(e){return e.filter((e=>"event"===e.type&&(e.size||"enum"!==e.kind))).reduce(((e,t)=>{const n=t.name.slice(t.name.lastIndexOf(":")+1),r={...t};return r.name=n,{...e,[A(cn.keccak(E(n)).toString(16))]:r}}),{})}function _a(e,t,n,r){return e.flat().reduce(((e,a)=>{const s=t[a.keys[0]];if(!s)return e;const i={};i[s.name]={},a.keys.shift();const o=a.keys[Symbol.iterator](),c=a.data[Symbol.iterator](),l=s.members?.filter((e=>"key"===e.kind))||s.keys,d=s.members?.filter((e=>"data"===e.kind))||s.data;return l.forEach((e=>{i[s.name][e.name]=Wt(o,e,n,r,i[s.name])})),d.forEach((e=>{i[s.name][e.name]=Wt(c,e,n,r,i[s.name])})),e.push(i),e}),[])}d(ya,{getAbiEvents:()=>ma,parseEvents:()=>_a});var Ea=e=>{const t=e[e.length-1];return"object"===typeof t&&["blockIdentifier","parseRequest","parseResponse","formatResponse","maxFee","nonce","signature","addressSalt"].some((e=>e in t))?{args:e,options:e.pop()}:{args:e}};function ba(e,t){return async function(...n){const r=Ea(n);return e.call(t.name,r.args,{parseRequest:!0,parseResponse:!0,...r.options})}}function Ca(e,t){return"view"===t.stateMutability||"view"===t.state_mutability?ba(e,t):function(e,t){return async function(...n){const r=Ea(n);return e.invoke(t.name,r.args,{parseRequest:!0,...r.options})}}(e,t)}function ka(e,t){return function(...n){return e.estimate(t.name,n)}}function wa(e,t){return Array.isArray(e)&&"__compiled__"in e?e:Array.isArray(e)&&Array.isArray(e[0])&&"__compiled__"in e[0]?e[0]:t()}var va=class{constructor(e,t,n=fa){this.address=t&&t.toLowerCase(),this.providerOrAccount=n,this.callData=new rn(e),this.structs=rn.getAbiStruct(e),this.events=ma(e);const r=Lt(e);this.abi=r.getLegacyFormat();const a={enumerable:!0,value:{},writable:!1};Object.defineProperties(this,{functions:{enumerable:!0,value:{},writable:!1},callStatic:{enumerable:!0,value:{},writable:!1},populateTransaction:{enumerable:!0,value:{},writable:!1},estimateFee:{enumerable:!0,value:{},writable:!1}}),this.abi.forEach((e=>{if("function"!==e.type)return;const t=e.name;var n,r;this[t]||Object.defineProperty(this,t,{...a,value:Ca(this,e)}),this.functions[t]||Object.defineProperty(this.functions,t,{...a,value:Ca(this,e)}),this.callStatic[t]||Object.defineProperty(this.callStatic,t,{...a,value:ba(this,e)}),this.populateTransaction[t]||Object.defineProperty(this.populateTransaction,t,{...a,value:(n=this,r=e,function(...e){return n.populate(r.name,e)})}),this.estimateFee[t]||Object.defineProperty(this.estimateFee,t,{...a,value:ka(this,e)})}))}attach(e){this.address=e}connect(e){this.providerOrAccount=e}async deployed(){return this.deployTransactionHash&&(await this.providerOrAccount.waitForTransaction(this.deployTransactionHash),this.deployTransactionHash=void 0),this}async call(e,t=[],{parseRequest:n=!0,parseResponse:r=!0,formatResponse:a,blockIdentifier:s}={}){Ee(null!==this.address,"contract is not connected to an address");const i=wa(t,(()=>n?(this.callData.validate("CALL",e,t),this.callData.compile(e,t)):(console.warn("Call skipped parsing but provided rawArgs, possible malfunction request"),t)));return this.providerOrAccount.callContract({contractAddress:this.address,calldata:i,entrypoint:e},s).then((t=>r?a?this.callData.format(e,t.result,a):this.callData.parse(e,t.result):t.result))}invoke(e,t=[],{parseRequest:n=!0,maxFee:r,nonce:a,signature:s}={}){Ee(null!==this.address,"contract is not connected to an address");const i=wa(t,(()=>n?(this.callData.validate("INVOKE",e,t),this.callData.compile(e,t)):(console.warn("Invoke skipped parsing but provided rawArgs, possible malfunction request"),t))),o={contractAddress:this.address,calldata:i,entrypoint:e};if("execute"in this.providerOrAccount)return this.providerOrAccount.execute(o,void 0,{maxFee:r,nonce:a});if(!a)throw new Error("Nonce is required when invoking a function without an account");return console.warn(`Invoking ${e} without an account. This will not work on a public node.`),this.providerOrAccount.invokeFunction({...o,signature:s},{nonce:a})}async estimate(e,t=[]){Ee(null!==this.address,"contract is not connected to an address"),wa(t,(()=>!1))||this.callData.validate("INVOKE",e,t);const n=this.populate(e,t);if("estimateInvokeFee"in this.providerOrAccount)return this.providerOrAccount.estimateInvokeFee(n);throw Error("Contract must be connected to the account contract to estimate")}populate(e,t=[]){const n=wa(t,(()=>this.callData.compile(e,t)));return{contractAddress:this.address,entrypoint:e,calldata:n}}parseEvents(e){return _a(e.events?.filter((e=>Oe(e.from_address)===Oe(this.address)),[])||[],this.events,this.structs,rn.getAbiEnum(this.abi))}isCairo1(){return tt.isCairo1Abi(this.abi)}async getVersion(){return this.providerOrAccount.getContractVersion(this.address)}typed(e){return this}},Aa=class{},Ta=class{constructor(e){this.compiledContract=e.compiledContract,this.account=e.account,this.casm=e.casm,this.abi=e.abi??e.compiledContract.abi,this.classHash=e.classHash,this.compiledClassHash=e.compiledClassHash,this.CallData=new rn(this.abi)}async deploy(...e){const{args:t,options:n={parseRequest:!0}}=Ea(e),r=wa(t,(()=>n.parseRequest?(this.CallData.validate("DEPLOY","constructor",t),this.CallData.compile("constructor",t)):(console.warn("Call skipped parsing but provided rawArgs, possible malfunction request"),t))),{deploy:{contract_address:a,transaction_hash:s}}=await this.account.declareAndDeploy({contract:this.compiledContract,casm:this.casm,classHash:this.classHash,compiledClassHash:this.compiledClassHash,constructorCalldata:r,salt:n.addressSalt});Ee(Boolean(a),"Deployment of the contract failed");const i=new va(this.compiledContract.abi,a,this.account);return i.deployTransactionHash=s,i}connect(e){return this.account=e,this}attach(e){return new va(this.abi,e,this.account)}},Ia=n(40219);function Sa(e){return A(v(Ae(e)).padStart(64,"0"))}function Oa(e){Ne(e,L,B,"Starknet Address");const t=Sa(e);if(!t.match(/^(0x)?[0-9a-fA-F]{64}$/))throw new Error("Invalid Address Format");return t}function Na(e){const t=v(Oa(e)).toLowerCase().split(""),n=v(Ue(e)),r=(0,Ia.hexToBytes)(n.padStart(64,"0"));for(let a=0;a<t.length;a+=2)r[a>>1]>>4>=8&&(t[a]=t[a].toUpperCase()),(15&r[a>>1])>=8&&(t[a+1]=t[a+1].toUpperCase());return A(t.join(""))}function xa(e){return Na(e)===e}var Da=be}}]);